# ­Ъџе лџлалўлблўлДлЋлАлџлљл» лЪлалълЉлЏлЋлюлљ лалЋлелЋлЮлљ! лЊлълблълњлФ лўлАлЪлалљлњлЏлЋлЮлЮлФлЋ лцлљлЎлЏлФ!

## ­ЪЊІ **лљлЮлљлЏлўлЌ лЪлълћлблњлЋлалќлћлЋлЮ:**

**РюЁ лћлИл░л│лйлЙли ЛѓлЙЛЄлйЛІл╣:** лЪлЙл╗ЛїлилЙл▓л░Лѓлхл╗Лї ЛЂл╗ЛІЛѕл░л╗ л┐ЛђлИл▓лхЛѓЛЂЛѓл▓лИлх, лйлЙ лйлх ЛЂл╗ЛІЛѕл░л╗ лЙЛЂлйлЙл▓лйЛІлх лЙЛѓл▓лхЛѓЛІ л▒лЙЛѓл░
**РюЁ лџлЙЛђлйлхл▓л░ЛЈ л┐ЛђлИЛЄлИлйл░ лйл░л╣л┤лхлйл░:** `ParallelTTSProcessor` лИЛЂл┐лЙл╗ЛїлиЛЃлхЛѓ **лЌлљлЊлЏлБлелџлў** л▓л╝лхЛЂЛѓлЙ Лђлхл░л╗ЛїлйлЙл│лЙ л▓лЙЛЂл┐ЛђлЙлИлил▓лхл┤лхлйлИЛЈ
**РюЁ лалхЛѕлхлйлИлх л│лЙЛѓлЙл▓лЙ:** лАлЙлил┤л░лй `SequentialTTSProcessor` ЛЂ **лалЋлљлЏлглЮлФлю л▓лЙЛЂл┐ЛђлЙлИлил▓лхл┤лхлйлИлхл╝**

***

## ­ЪћД **лџлалўлблўлДлЋлАлџлўлЋ лўлАлЪлалљлњлЏлЋлЮлўл» лњ лЊлълблълњлФлЦ лцлљлЎлЏлљлЦ:**

### **1. `sequential_tts.py` - лалЋлљлЏлглЮлљл» лЙл▒Лђл░л▒лЙЛѓл║л░ ЛЄл░лйл║лЙл▓**
**лЌл░л╝лхлйЛЈлхЛѓ:** `ParallelTTSProcessor` ЛЂ лил░л│л╗ЛЃЛѕл║л░л╝лИ
**лџл╗ЛјЛЄлхл▓ЛІлх лИЛЂл┐Лђл░л▓л╗лхлйлИЛЈ:**
- РюЁ **лалхл░л╗ЛїлйлЙлх л▓лЙЛЂл┐ЛђлЙлИлил▓лхл┤лхлйлИлх** ЛЄлхЛђлхли ARI (лйлх `await asyncio.sleep(0.1)`)
- РюЁ **лЪЛђлЙл▓лхЛђл║л░ л║л░лйл░л╗лЙл▓** л┐лхЛђлхл┤ л║л░лХл┤лЙл╣ лЙл┐лхЛђл░ЛєлИлхл╣  
- РюЁ **лЪлЙЛЂл╗лхл┤лЙл▓л░Лѓлхл╗Лїлйл░ЛЈ лЙл▒Лђл░л▒лЙЛѓл║л░** л┤л╗ЛЈ ЛЂЛѓл░л▒лИл╗ЛїлйлЙЛЂЛѓлИ
- РюЁ **лЮлхл╝лхл┤л╗лхлйлйлЙлх л▓лЙЛЂл┐ЛђлЙлИлил▓лхл┤лхлйлИлх** л║л░лХл┤лЙл│лЙ ЛЄл░лйл║л░

"""
import aiohttp
import asyncio
import json
import logging
from typing import Optional

logger = logging.getLogger(__name__)

class AsteriskARIClient:
    def __init__(self, host="localhost", port=8088, username="asterisk", password="asterisk123"):
        self.base_url = f"http://{host}:{port}/ari"
        self.auth = aiohttp.BasicAuth(username, password)
        self.session = None
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(auth=self.auth)
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def answer_channel(self, channel_id):
        """лаЛЏлАРђџлалєла┬хлАРђАла┬░ла┬хлАРђџ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ ламЉла┬╗лАлЈ лаЛћлаЛЋлАлѓлАлѓла┬хлаЛћлАРђџлалЁлаЛЋлаРёќ лАлѓла┬░ла┬▒лаЛЋлАРђџлАРђ╣ ARI playback"""
        try:
            url = f"{self.base_url}/channels/{channel_id}/answer"
            async with self.session.post(url) as response:
                if response.status == 204:
                    logger.info(f"л▓ЛџРђд лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лАЛЊлАлЃлаЛЌла┬хлАРѓглалЁлаЛЋ лаЛЋлАРђџлалєла┬хлАРђАла┬хлалЁ")
                    return True
                else:
                    error_text = await response.text()
                    logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлАРђџлалєла┬хлАРђџла┬░ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗: {response.status} - {error_text}")
                    return False
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлАРђџлалєла┬хлАРђџла┬░ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ {channel_id}: {e}")
            return False
    
    async def play_sound(self, channel_id, sound_id, lang="ru"):
        """
        лаЛЪлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░ла┬хлАРђџ ла┬илалєлАЛЊлаЛћлаЛЋлалєлаЛЋлаРёќ лАРђъла┬░лаРёќла┬╗ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ла┬х.
        
        Args:
            channel_id: ID лаЛћла┬░лалЁла┬░ла┬╗ла┬░
            sound_id: ла┬ўлаЛўлАлЈ ла┬илалєлАЛЊлаЛћлаЛЋлалєлаЛЋлаЛќлаЛЋ лАРђъла┬░лаРёќла┬╗ла┬░ (ла┬▒ла┬хла┬и лАлѓла┬░лАлЃлАРѓглаЛЉлАлѓла┬хлалЁлаЛЉлАлЈ)
            lang: лалЄла┬илАРђ╣лаЛћ (лаЛЌла┬░лаЛЌлаЛћла┬░ лалє sounds/)
        """
        # ЛђЛЪлІлЄ лалаЛълаЛњлаЛЪ 2.3: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉла┬хлаЛў
        if not await self.channel_exists(channel_id):
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉла┬х")
            return None
            
        try:
            url = f"{self.base_url}/channels/{channel_id}/play"
            # ла┬ўлалјлаЛЪла лаЛњлаРђЎлаРђ║лаРђблаЛюлаЛЏ: лалѕла┬▒лаЛЉлАлѓла┬░ла┬хлаЛў лаЛЌлаЛЋламЉлаЛЌла┬░лаЛЌлаЛћлАЛЊ ru/ - Asterisk лАлЃла┬░лаЛў лалЁла┬░лаРёќламЉла┬хлАРђџ лАРђъла┬░лаРёќла┬╗ лаЛЌлаЛЋ лаЛЉлаЛўла┬хлалЁлаЛЉ
            media = f"sound:{sound_id}"
            data = {"media": media}
            
            logger.info(f"лаЛЪлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░ла┬хлаЛў ла┬илалєлАЛЊлаЛћ: {media} лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ла┬х {channel_id}")
            
            async with self.session.post(url, json=data) as response:
                # лаРђЮлаРђблаЛълаЛњлаРђ║ла┬глаЛюлаЛЏлаРђб лаРђ║лаЛЏлаРђюла┬ўла лаЛЏлаРђЎлаЛњлаЛюла┬ўлаРђб: лаРђ║лаЛЋлаЛќлаЛЉлАлѓлАЛЊла┬хлаЛў лаЛЌлаЛЋла┬╗лалЁлАРђ╣лаРёќ лаЛЋлАРђџлалєла┬хлАРђџ ARI ламЉла┬╗лАлЈ ламЉлаЛЉла┬░лаЛќлалЁлаЛЋлАлЃлАРђџлаЛЉлаЛћлаЛЉ
                response_text = await response.text()
                logger.info(f"ЛђЛЪРђЮлї ARI Response: status={response.status}, body={response_text}")
                
                # ARI лаЛўлаЛЋла┬Хла┬хлАРђџ лалєлаЛЋла┬илалєлАлѓла┬░лАРђ░ла┬░лАРђџлАлі 200 OK лаЛЉла┬╗лаЛЉ 201 Created/202 Accepted лаЛЌлАлѓлаЛЉ лАЛЊлАлЃлаЛЌла┬хлАРѓглалЁлаЛЋлаЛў лАлЃлаЛЋла┬иламЉла┬░лалЁлаЛЉлаЛЉ playback
                if response.status in (200, 201, 202):
                    try:
                        result = json.loads(response_text)
                        playback_id = result.get('id')
                        logger.info(f"л▓ЛџРђд лаЛЪлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░лалЁлаЛЉла┬х лаЛЌлАлѓлаЛЉлалЁлАлЈлАРђџлаЛЋ ARI (status={response.status}), playback_id={playback_id}")
                        return playback_id or True
                    except Exception as e:
                        logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛюла┬х лАЛЊламЉла┬░ла┬╗лаЛЋлАлЃлАлі лАлѓла┬░лАлЃлаЛЌла┬░лАлѓлАлЃлаЛЉлАРђџлАлі JSON лаЛЋлАРђџлалєла┬хлАРђџ: {e}, raw: {response_text}")
                        return True  # лаРђЎлаЛЋла┬илалєлАлѓла┬░лАРђ░ла┬░ла┬хлаЛў True ла┬хлАлЃла┬╗лаЛЉ лАлЃлАРђџла┬░лАРђџлАЛЊлАлЃ OK
                else:
                    logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЌлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░лалЁлаЛЉлАлЈ: {response.status} - {response_text}")
                    return None
                    
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЌлАлѓлаЛЉ лаЛЌлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░лалЁлаЛЉлаЛЉ ла┬илалєлАЛЊлаЛћла┬░: {e}")
            return None

    async def start_recording(self, channel_id, filename, max_duration=15):
        """
        лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлАРђџ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лАлЃ лаЛћла┬░лалЁла┬░ла┬╗ла┬░.
        
        Args:
            channel_id: ID лаЛћла┬░лалЁла┬░ла┬╗ла┬░
            filename: ла┬ўлаЛўлАлЈ лАРђъла┬░лаРёќла┬╗ла┬░ ламЉла┬╗лАлЈ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ (ла┬▒ла┬хла┬и лАлѓла┬░лАлЃлАРѓглаЛЉлАлѓла┬хлалЁлаЛЉлАлЈ)
            max_duration: лаЛџла┬░лаЛћлАлЃлаЛЉлаЛўла┬░ла┬╗лАлілалЁла┬░лАлЈ ламЉла┬╗лаЛЉлАРђџла┬хла┬╗лАлілалЁлаЛЋлАлЃлАРђџлАлі лалє лАлЃла┬хлаЛћлАЛЊлалЁламЉла┬░лАРђд
        """
        # ЛђЛЪлІлЄ лалаЛълаЛњлаЛЪ 2.3: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлілАлІ
        if not await self.channel_exists(channel_id):
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі")
            return False
            
        try:
            url = f"{self.base_url}/channels/{channel_id}/record"
            data = {
                "name": filename,
                "format": "wav",
                "maxDurationSeconds": max_duration,
                "beep": False,
                "terminateOn": "#",  # лаРђћла┬░лалєла┬хлАлѓлАРѓглаЛЉлАРђџлАлі ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лаЛЌлаЛЋ лалЁла┬░ла┬Хла┬░лАРђџлаЛЉлАлІ #
                "ifExists": "overwrite"
            }
            
            logger.info(f"лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі: {filename} лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ла┬х {channel_id}")
            
            async with self.session.post(url, json=data) as response:
                # ARI лаЛўлаЛЋла┬Хла┬хлАРђџ лалєлаЛЋла┬илалєлАлѓла┬░лАРђ░ла┬░лАРђџлАлі 200 OK лаЛЉла┬╗лаЛЉ 201 Created лаЛЌлАлѓлаЛЉ лАЛЊлАлЃлаЛЌла┬хлАРѓглалЁлаЛЋлаЛў лАлЃлаЛЋла┬иламЉла┬░лалЁлаЛЉлаЛЉ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ
                if response.status in (200, 201):
                    result = await response.json()
                    recording_id = result.get('name')
                    logger.info(f"л▓ЛџРђд лаРђћла┬░лаЛЌлаЛЉлАлЃлАлі ла┬ила┬░лаЛЌлАЛЊлАРђ░ла┬хлалЁла┬░: {recording_id}")
                    return recording_id
                else:
                    error_text = await response.text()
                    logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {response.status} - {error_text}")
                    return None
                    
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЌлАлѓлаЛЉ ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬х ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {e}")
            return None

    async def stop_recording(self, recording_id):
        """лаЛЏлАлЃлАРђџла┬░лалЁла┬░лалєла┬╗лаЛЉлалєла┬░ла┬хлАРђџ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі."""
        try:
            url = f"{self.base_url}/recordings/live/{recording_id}/stop"
            async with self.session.post(url) as response:
                return response.status == 200
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлАлЃлАРђџла┬░лалЁлаЛЋлалєлаЛћлаЛЉ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {e}")
            return False

    async def hold_channel(self, channel_id):
        """лалѕламЉла┬хлАлѓла┬ХлаЛЉлалєла┬░ла┬хлАРђџ лаЛћла┬░лалЁла┬░ла┬╗ - лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлі лалЁла┬х лаЛўлаЛЋла┬Хла┬хлАРђџ лаЛЌлаЛЋлалєла┬хлАлЃлаЛЉлАРђџлАлі лАРђџлАлѓлАЛЊла┬▒лаЛћлАЛЊ."""
        # ЛђЛЪлІлЄ лалаЛълаЛњлаЛЪ 2.3: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ лАЛЊламЉла┬хлАлѓла┬Хла┬░лалЁлаЛЉла┬хлаЛў
        if not await self.channel_exists(channel_id):
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў лАЛЊламЉла┬хлАлѓла┬Хла┬░лалЁлаЛЉла┬х")
            return False
            
        try:
            url = f"{self.base_url}/channels/{channel_id}/hold"
            async with self.session.post(url) as response:
                if response.status in (200, 201):
                    logger.info(f"л▓ЛџРђд лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лАЛЊламЉла┬хлАлѓла┬Хла┬░лалЁ")
                    return True
                else:
                    error_text = await response.text()
                    logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛюла┬х лАЛЊламЉла┬░ла┬╗лаЛЋлАлЃлАлі лАЛЊламЉла┬хлАлѓла┬Хла┬░лАРђџлАлі лаЛћла┬░лалЁла┬░ла┬╗ {channel_id}: {response.status} - {error_text}")
                    return False
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лАЛЊламЉла┬хлАлѓла┬Хла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ {channel_id}: {e}")
            return False

    async def hangup_channel(self, channel_id):
        """лаРђћла┬░лалєла┬хлАлѓлАРѓгла┬░ла┬хлАРђџ ла┬илалєлаЛЋлалЁлаЛЋлаЛћ."""
        # ЛђЛЪлІлЄ лалаЛълаЛњлаЛЪ 2.3: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉла┬хлаЛў
        if not await self.channel_exists(channel_id):
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉла┬х")
            return False
            
        try:
            url = f"{self.base_url}/channels/{channel_id}"
            async with self.session.delete(url) as response:
                return response.status == 200
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉлАлЈ ла┬илалєлаЛЋлалЁлаЛћла┬░: {e}")
            return False
    
    async def channel_exists(self, channel_id):
        """лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлАлЈла┬хлАРђџ, лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ ла┬╗лаЛЉ лаЛћла┬░лалЁла┬░ла┬╗ лалє Asterisk."""
        try:
            url = f"{self.base_url}/channels/{channel_id}"
            async with self.session.get(url) as response:
                return response.status == 200
        except Exception as e:
            logger.debug(f"лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лалЁла┬░лаРёќламЉла┬хлалЁ: {e}")
            return False

if __name__ == "__main__":
    async def test():
        async with AsteriskARIClient() as ari:
            url = f"{ari.base_url}/asterisk/info"
            async with ari.session.get(url) as response:
                if response.status == 200:
                    print("ARI connection successful!")
                else:
                    print(f"ARI connection failed: {response.status}")
    
    asyncio.run(test())
"""

### **2. `stasis_fixed.py` - лўЛЂл┐Лђл░л▓л╗лхлйлйЛІл╣ лЙЛЂлйлЙл▓лйлЙл╣ лЙл▒Лђл░л▒лЙЛѓЛЄлИл║**
**лЌл░л╝лхлйЛЈлхЛѓ:** `stasis_handler_optimized.py`
**лџл╗ЛјЛЄлхл▓ЛІлх лИЛЂл┐Лђл░л▓л╗лхлйлИЛЈ:**
- РюЁ **Hold/Unhold л║л░лйл░л╗лЙл▓** л┤л╗ЛЈ л┐Лђлхл┤лЙЛѓл▓Лђл░ЛЅлхлйлИЛЈ лил░л║ЛђЛІЛѓлИЛЈ
- РюЁ **SequentialTTSProcessor** л▓л╝лхЛЂЛѓлЙ Parallel
- РюЁ **лАлИлйЛЁЛђлЙлйлИлил░ЛєлИЛЈ лХлИлилйлхлйлйлЙл│лЙ ЛєлИл║л╗л░** л║л░лйл░л╗л░ ЛЂ лЙл▒Лђл░л▒лЙЛѓл║лЙл╣
- РюЁ **лБл╗ЛЃЛЄЛѕлхлйлйл░ЛЈ лЙл▒Лђл░л▒лЙЛѓл║л░ лЙЛѕлИл▒лЙл║**

"""
import aiohttp
import asyncio
import json
import logging
from typing import Optional

logger = logging.getLogger(__name__)

class AsteriskARIClient:
    def __init__(self, host="localhost", port=8088, username="asterisk", password="asterisk123"):
        self.base_url = f"http://{host}:{port}/ari"
        self.auth = aiohttp.BasicAuth(username, password)
        self.session = None
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(auth=self.auth)
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def answer_channel(self, channel_id):
        """лаЛЏлАРђџлалєла┬хлАРђАла┬░ла┬хлАРђџ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ ламЉла┬╗лАлЈ лаЛћлаЛЋлАлѓлАлѓла┬хлаЛћлАРђџлалЁлаЛЋлаРёќ лАлѓла┬░ла┬▒лаЛЋлАРђџлАРђ╣ ARI playback"""
        try:
            url = f"{self.base_url}/channels/{channel_id}/answer"
            async with self.session.post(url) as response:
                if response.status == 204:
                    logger.info(f"л▓ЛџРђд лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лАЛЊлАлЃлаЛЌла┬хлАРѓглалЁлаЛЋ лаЛЋлАРђџлалєла┬хлАРђАла┬хлалЁ")
                    return True
                else:
                    error_text = await response.text()
                    logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлАРђџлалєла┬хлАРђџла┬░ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗: {response.status} - {error_text}")
                    return False
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлАРђџлалєла┬хлАРђџла┬░ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ {channel_id}: {e}")
            return False
    
    async def play_sound(self, channel_id, sound_id, lang="ru"):
        """
        лаЛЪлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░ла┬хлАРђџ ла┬илалєлАЛЊлаЛћлаЛЋлалєлаЛЋлаРёќ лАРђъла┬░лаРёќла┬╗ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ла┬х.
        
        Args:
            channel_id: ID лаЛћла┬░лалЁла┬░ла┬╗ла┬░
            sound_id: ла┬ўлаЛўлАлЈ ла┬илалєлАЛЊлаЛћлаЛЋлалєлаЛЋлаЛќлаЛЋ лАРђъла┬░лаРёќла┬╗ла┬░ (ла┬▒ла┬хла┬и лАлѓла┬░лАлЃлАРѓглаЛЉлАлѓла┬хлалЁлаЛЉлАлЈ)
            lang: лалЄла┬илАРђ╣лаЛћ (лаЛЌла┬░лаЛЌлаЛћла┬░ лалє sounds/)
        """
        # ЛђЛЪлІлЄ лалаЛълаЛњлаЛЪ 2.3: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉла┬хлаЛў
        if not await self.channel_exists(channel_id):
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉла┬х")
            return None
            
        try:
            url = f"{self.base_url}/channels/{channel_id}/play"
            # ла┬ўлалјлаЛЪла лаЛњлаРђЎлаРђ║лаРђблаЛюлаЛЏ: лалѕла┬▒лаЛЉлАлѓла┬░ла┬хлаЛў лаЛЌлаЛЋламЉлаЛЌла┬░лаЛЌлаЛћлАЛЊ ru/ - Asterisk лАлЃла┬░лаЛў лалЁла┬░лаРёќламЉла┬хлАРђџ лАРђъла┬░лаРёќла┬╗ лаЛЌлаЛЋ лаЛЉлаЛўла┬хлалЁлаЛЉ
            media = f"sound:{sound_id}"
            data = {"media": media}
            
            logger.info(f"лаЛЪлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░ла┬хлаЛў ла┬илалєлАЛЊлаЛћ: {media} лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ла┬х {channel_id}")
            
            async with self.session.post(url, json=data) as response:
                # лаРђЮлаРђблаЛълаЛњлаРђ║ла┬глаЛюлаЛЏлаРђб лаРђ║лаЛЏлаРђюла┬ўла лаЛЏлаРђЎлаЛњлаЛюла┬ўлаРђб: лаРђ║лаЛЋлаЛќлаЛЉлАлѓлАЛЊла┬хлаЛў лаЛЌлаЛЋла┬╗лалЁлАРђ╣лаРёќ лаЛЋлАРђџлалєла┬хлАРђџ ARI ламЉла┬╗лАлЈ ламЉлаЛЉла┬░лаЛќлалЁлаЛЋлАлЃлАРђџлаЛЉлаЛћлаЛЉ
                response_text = await response.text()
                logger.info(f"ЛђЛЪРђЮлї ARI Response: status={response.status}, body={response_text}")
                
                # ARI лаЛўлаЛЋла┬Хла┬хлАРђџ лалєлаЛЋла┬илалєлАлѓла┬░лАРђ░ла┬░лАРђџлАлі 200 OK лаЛЉла┬╗лаЛЉ 201 Created/202 Accepted лаЛЌлАлѓлаЛЉ лАЛЊлАлЃлаЛЌла┬хлАРѓглалЁлаЛЋлаЛў лАлЃлаЛЋла┬иламЉла┬░лалЁлаЛЉлаЛЉ playback
                if response.status in (200, 201, 202):
                    try:
                        result = json.loads(response_text)
                        playback_id = result.get('id')
                        logger.info(f"л▓ЛџРђд лаЛЪлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░лалЁлаЛЉла┬х лаЛЌлАлѓлаЛЉлалЁлАлЈлАРђџлаЛЋ ARI (status={response.status}), playback_id={playback_id}")
                        return playback_id or True
                    except Exception as e:
                        logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛюла┬х лАЛЊламЉла┬░ла┬╗лаЛЋлАлЃлАлі лАлѓла┬░лАлЃлаЛЌла┬░лАлѓлАлЃлаЛЉлАРђџлАлі JSON лаЛЋлАРђџлалєла┬хлАРђџ: {e}, raw: {response_text}")
                        return True  # лаРђЎлаЛЋла┬илалєлАлѓла┬░лАРђ░ла┬░ла┬хлаЛў True ла┬хлАлЃла┬╗лаЛЉ лАлЃлАРђџла┬░лАРђџлАЛЊлАлЃ OK
                else:
                    logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЌлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░лалЁлаЛЉлАлЈ: {response.status} - {response_text}")
                    return None
                    
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЌлАлѓлаЛЉ лаЛЌлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░лалЁлаЛЉлаЛЉ ла┬илалєлАЛЊлаЛћла┬░: {e}")
            return None

    async def start_recording(self, channel_id, filename, max_duration=15):
        """
        лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлАРђџ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лАлЃ лаЛћла┬░лалЁла┬░ла┬╗ла┬░.
        
        Args:
            channel_id: ID лаЛћла┬░лалЁла┬░ла┬╗ла┬░
            filename: ла┬ўлаЛўлАлЈ лАРђъла┬░лаРёќла┬╗ла┬░ ламЉла┬╗лАлЈ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ (ла┬▒ла┬хла┬и лАлѓла┬░лАлЃлАРѓглаЛЉлАлѓла┬хлалЁлаЛЉлАлЈ)
            max_duration: лаЛџла┬░лаЛћлАлЃлаЛЉлаЛўла┬░ла┬╗лАлілалЁла┬░лАлЈ ламЉла┬╗лаЛЉлАРђџла┬хла┬╗лАлілалЁлаЛЋлАлЃлАРђџлАлі лалє лАлЃла┬хлаЛћлАЛЊлалЁламЉла┬░лАРђд
        """
        # ЛђЛЪлІлЄ лалаЛълаЛњлаЛЪ 2.3: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлілАлІ
        if not await self.channel_exists(channel_id):
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі")
            return False
            
        try:
            url = f"{self.base_url}/channels/{channel_id}/record"
            data = {
                "name": filename,
                "format": "wav",
                "maxDurationSeconds": max_duration,
                "beep": False,
                "terminateOn": "#",  # лаРђћла┬░лалєла┬хлАлѓлАРѓглаЛЉлАРђџлАлі ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лаЛЌлаЛЋ лалЁла┬░ла┬Хла┬░лАРђџлаЛЉлАлІ #
                "ifExists": "overwrite"
            }
            
            logger.info(f"лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі: {filename} лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ла┬х {channel_id}")
            
            async with self.session.post(url, json=data) as response:
                # ARI лаЛўлаЛЋла┬Хла┬хлАРђџ лалєлаЛЋла┬илалєлАлѓла┬░лАРђ░ла┬░лАРђџлАлі 200 OK лаЛЉла┬╗лаЛЉ 201 Created лаЛЌлАлѓлаЛЉ лАЛЊлАлЃлаЛЌла┬хлАРѓглалЁлаЛЋлаЛў лАлЃлаЛЋла┬иламЉла┬░лалЁлаЛЉлаЛЉ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ
                if response.status in (200, 201):
                    result = await response.json()
                    recording_id = result.get('name')
                    logger.info(f"л▓ЛџРђд лаРђћла┬░лаЛЌлаЛЉлАлЃлАлі ла┬ила┬░лаЛЌлАЛЊлАРђ░ла┬хлалЁла┬░: {recording_id}")
                    return recording_id
                else:
                    error_text = await response.text()
                    logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {response.status} - {error_text}")
                    return None
                    
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЌлАлѓлаЛЉ ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬х ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {e}")
            return None

    async def stop_recording(self, recording_id):
        """лаЛЏлАлЃлАРђџла┬░лалЁла┬░лалєла┬╗лаЛЉлалєла┬░ла┬хлАРђџ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі."""
        try:
            url = f"{self.base_url}/recordings/live/{recording_id}/stop"
            async with self.session.post(url) as response:
                return response.status == 200
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлАлЃлАРђџла┬░лалЁлаЛЋлалєлаЛћлаЛЉ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {e}")
            return False

    async def hold_channel(self, channel_id):
        """лалѕламЉла┬хлАлѓла┬ХлаЛЉлалєла┬░ла┬хлАРђџ лаЛћла┬░лалЁла┬░ла┬╗ - лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлі лалЁла┬х лаЛўлаЛЋла┬Хла┬хлАРђџ лаЛЌлаЛЋлалєла┬хлАлЃлаЛЉлАРђџлАлі лАРђџлАлѓлАЛЊла┬▒лаЛћлАЛЊ."""
        # ЛђЛЪлІлЄ лалаЛълаЛњлаЛЪ 2.3: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ лАЛЊламЉла┬хлАлѓла┬Хла┬░лалЁлаЛЉла┬хлаЛў
        if not await self.channel_exists(channel_id):
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў лАЛЊламЉла┬хлАлѓла┬Хла┬░лалЁлаЛЉла┬х")
            return False
            
        try:
            url = f"{self.base_url}/channels/{channel_id}/hold"
            async with self.session.post(url) as response:
                if response.status in (200, 201):
                    logger.info(f"л▓ЛџРђд лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лАЛЊламЉла┬хлАлѓла┬Хла┬░лалЁ")
                    return True
                else:
                    error_text = await response.text()
                    logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛюла┬х лАЛЊламЉла┬░ла┬╗лаЛЋлАлЃлАлі лАЛЊламЉла┬хлАлѓла┬Хла┬░лАРђџлАлі лаЛћла┬░лалЁла┬░ла┬╗ {channel_id}: {response.status} - {error_text}")
                    return False
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лАЛЊламЉла┬хлАлѓла┬Хла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ {channel_id}: {e}")
            return False

    async def hangup_channel(self, channel_id):
        """лаРђћла┬░лалєла┬хлАлѓлАРѓгла┬░ла┬хлАРђџ ла┬илалєлаЛЋлалЁлаЛЋлаЛћ."""
        # ЛђЛЪлІлЄ лалаЛълаЛњлаЛЪ 2.3: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉлАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉла┬хлаЛў
        if not await self.channel_exists(channel_id):
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉла┬х")
            return False
            
        try:
            url = f"{self.base_url}/channels/{channel_id}"
            async with self.session.delete(url) as response:
                return response.status == 200
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉлАлЈ ла┬илалєлаЛЋлалЁлаЛћла┬░: {e}")
            return False
    
    async def channel_exists(self, channel_id):
        """лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлАлЈла┬хлАРђџ, лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ ла┬╗лаЛЉ лаЛћла┬░лалЁла┬░ла┬╗ лалє Asterisk."""
        try:
            url = f"{self.base_url}/channels/{channel_id}"
            async with self.session.get(url) as response:
                return response.status == 200
        except Exception as e:
            logger.debug(f"лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лалЁла┬░лаРёќламЉла┬хлалЁ: {e}")
            return False

if __name__ == "__main__":
    async def test():
        async with AsteriskARIClient() as ari:
            url = f"{ari.base_url}/asterisk/info"
            async with ari.session.get(url) as response:
                if response.status == 200:
                    print("ARI connection successful!")
                else:
                    print(f"ARI connection failed: {response.status}")
    
    asyncio.run(test())
"""

### **3. `ari_client_fixed.py` - лўЛЂл┐Лђл░л▓л╗лхлйлйЛІл╣ ARI л║л╗лИлхлйЛѓ**
**лЌл░л╝лхлйЛЈлхЛѓ:** `ari_client.py`  
**лџл╗ЛјЛЄлхл▓ЛІлх лИЛЂл┐Лђл░л▓л╗лхлйлИЛЈ:**
- РюЁ **`hold_channel()`** - л┐Лђлхл┤лЙЛѓл▓Лђл░ЛЅл░лхЛѓ лил░л║ЛђЛІЛѓлИлх л║л░лйл░л╗л░
- РюЁ **`unhold_channel()`** - л▓лЙлил▓Лђл░ЛЅл░лхЛѓ лйлЙЛђл╝л░л╗ЛїлйлЙлх ЛЂлЙЛЂЛѓлЙЛЈлйлИлх
- РюЁ **`stop_playback()`** - л┤л╗ЛЈ barge-in ЛёЛЃлйл║ЛєлИлЙлйл░л╗ЛїлйлЙЛЂЛѓлИ
- РюЁ **лБл╗ЛЃЛЄЛѕлхлйлйЛІлх л┐ЛђлЙл▓лхЛђл║лИ** ЛЂЛЃЛЅлхЛЂЛѓл▓лЙл▓л░лйлИЛЈ л║л░лйл░л╗лЙл▓

"""
#!/usr/bin/env python3
"""
лаЛЏлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлАРђ╣лаРёќ StasisHandler лАлЃ лаЛЉлалЁлАРђџла┬хлаЛќлАлѓла┬░лАРђалаЛЉла┬хлаРёќ лалєлАлЃла┬хлАРђд лаЛћлаЛЋлаЛўлаЛЌлаЛЋлалЁла┬хлалЁлАРђџлаЛЋлалє лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ
ла┬дла┬хла┬╗лАлі: 1.1 лАлЃла┬хлаЛћлАЛЊлалЁламЉлАРђ╣ лаЛЋлАРђџ ASR ламЉлаЛЋ лаЛЌла┬хлАлѓлалєлаЛЋлаЛќлаЛЋ ла┬илалєлАЛЊлаЛћла┬░
"""

import asyncio
import json
import logging
import websockets
import uuid
import os
import sys
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional

# лаРђЮлаЛЋла┬▒ла┬░лалєла┬╗лАлЈла┬хлаЛў лаЛЌлАЛЊлАРђџлАлі ламЉла┬╗лАлЈ лаЛЉлаЛўлаЛЌлаЛЋлАлѓлАРђџла┬░ лаЛўлаЛЋламЉлАЛЊла┬╗ла┬хлаРёќ лаЛЌлАлѓлаЛЋла┬хлаЛћлАРђџла┬░
current_dir = Path(__file__).parent
project_root = current_dir.parent.parent.parent
sys.path.insert(0, str(project_root))

from app.backend.asterisk.ari_client import AsteriskARIClient
from app.backend.rag.agent import Agent
from app.backend.services.yandex_tts_service import get_yandex_tts_service
from app.backend.services.asr_service import get_asr_service
from app.backend.utils.text_normalizer import normalize as normalize_text
from app.backend.services.log_storage import insert_log

# лаЛюлаЛЏлаРђЎла┬ФлаРђб лаЛЎлаЛЏлаЛџлаЛЪлаЛЏлаЛюлаРђблаЛюлаЛъла┬Ф лаЛЏлаЛЪлаЛъла┬ўлаЛџла┬ўлаРђћлаЛњла┬дла┬ўла┬ў
from app.backend.services.yandex_grpc_tts import YandexGrpcTTS
from app.backend.services.tts_adapter import TTSAdapter
from app.backend.services.filler_tts import InstantFillerTTS
from app.backend.services.parallel_tts import ParallelTTSProcessor

logger = logging.getLogger(__name__)

class OptimizedAsteriskAIHandler:
    """
    лаЛЏлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлАРђ╣лаРёќ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлАРђАлаЛЉлаЛћ Asterisk лАлЃ лаЛЉлалЁлАРђџла┬хлаЛќлАлѓла┬░лАРђалаЛЉла┬хлаРёќ лалєлАлЃла┬хлАРђд лаЛћлаЛЋлаЛўлаЛЌлаЛЋлалЁла┬хлалЁлАРђџлаЛЋлалє
    
    лаЛЎлаЛЋлаЛўлаЛЌлаЛЋлалЁла┬хлалЁлАРђџлАРђ╣:
    1. Yandex gRPC TTS - ла┬▒лАРђ╣лАлЃлАРђџлАлѓлАРђ╣лаРёќ лАлЃлаЛЉлалЁлАРђџла┬хла┬и лАлѓла┬хлАРђАлаЛЉ
    2. Chunked Response Generator - streaming AI лаЛЋлАРђџлалєла┬хлАРђџлАРђ╣
    3. Filler Words - лаЛўлаЛќлалЁлаЛЋлалєла┬хлалЁлалЁлАРђ╣ла┬х лаЛЌлАлЃлаЛЉлАРђдлаЛЋла┬╗лаЛЋлаЛќлаЛЉлАРђАла┬хлАлЃлаЛћлаЛЉла┬х лАлѓла┬хла┬░лаЛћлАРђалаЛЉлаЛЉ
    4. Parallel TTS Processor - лаЛЌла┬░лАлѓла┬░ла┬╗ла┬╗ла┬хла┬╗лАлілалЁла┬░лАлЈ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћла┬░ лАРђАла┬░лалЁлаЛћлаЛЋлалє
    """
    
    def __init__(self):
        self.ws_url = "ws://localhost:8088/ari/events?app=asterisk-bot&api_key=asterisk:asterisk123"
        
        # ла┬ўлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬илаЛЉлАлѓлАЛЊла┬хлаЛў AI Agent
        try:
            self.agent = Agent()
            logger.info("л▓ЛџРђд AI Agent лАЛЊлАлЃлаЛЌла┬хлАРѓглалЁлаЛЋ лаЛЉлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁ")
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЉлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ AI Agent: {e}")
            self.agent = None
        
        # ла┬ўлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬илаЛЉлАлѓлАЛЊла┬хлаЛў ASR лАлЃла┬хлАлѓлалєлаЛЉлАлЃ
        try:
            self.asr = get_asr_service()
            logger.info("л▓ЛџРђд ASR лАлЃла┬хлАлѓлалєлаЛЉлАлЃ лаЛЉлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁ")
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЉлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ ASR: {e}")
            self.asr = None
        
        # лаЛюлаЛЏлаРђЎла┬ФлаРђб лаЛЎлаЛЏлаЛџлаЛЪлаЛЏлаЛюлаРђблаЛюлаЛъла┬Ф лаЛЏлаЛЪлаЛъла┬ўлаЛџла┬ўлаРђћлаЛњла┬дла┬ўла┬ў
        self.grpc_tts = None
        self.tts_adapter = None
        self.filler_tts = None
        self.parallel_tts = None
        
        # лаЛњлаЛћлАРђџлаЛЉлалєлалЁлАРђ╣ла┬х ла┬илалєлаЛЋлалЁлаЛћлаЛЉ лАлЃ лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлАРђ╣лаЛўлаЛЉ ламЉла┬░лалЁлалЁлАРђ╣лаЛўлаЛЉ
        self.active_calls = {}
        
        # лаЛЎлаЛЋлалЁлАлЃлАРђџла┬░лалЁлАРђџлАРђ╣ лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ
        self.SPEECH_END_TIMEOUT = 0.2
        self.BARGE_IN_GUARD_MS = 1500  # лалѕлалєла┬хла┬╗лаЛЉлАРђАла┬хлалЁлаЛЋ ламЉла┬╗лАлЈ Asterisk
        self.INPUT_DEBOUNCE_MS = 1200
        
        # лаЛџла┬хлАРђџлАлѓлаЛЉлаЛћлаЛЉ лаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлАРђџла┬хла┬╗лАлілалЁлаЛЋлАлЃлАРђџлаЛЉ
        self.performance_metrics = {}
        
        logger.info("ЛђЛЪЛЎлѓ OptimizedAsteriskAIHandler лаЛЉлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁ")
    
    async def initialize_optimization_services(self):
        """ла┬ўлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬ила┬░лАРђалаЛЉлАлЈ лалєлАлЃла┬хлАРђд лАлЃла┬хлАлѓлалєлаЛЉлАлЃлаЛЋлалє лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ"""
        try:
            logger.info("ЛђЛЪРђЮРђъ ла┬ўлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬ила┬░лАРђалаЛЉлАлЈ лАлЃла┬хлАлѓлалєлаЛЉлАлЃлаЛЋлалє лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ...")
            
            # 1. Yandex gRPC TTS
            self.grpc_tts = YandexGrpcTTS()
            await self.grpc_tts.initialize()
            
            # 2. TTS Adapter (gRPC + HTTP fallback)
            self.tts_adapter = TTSAdapter()
            await self.tts_adapter.initialize()
            
            # 3. Filler TTS
            self.filler_tts = InstantFillerTTS()
            await self.filler_tts.initialize()
            
            # 4. Parallel TTS Processor
            ari_client = AsteriskARIClient()
            self.parallel_tts = ParallelTTSProcessor(self.grpc_tts, ari_client)
            
            logger.info("л▓ЛџРђд лаРђЎлАлЃла┬х лАлЃла┬хлАлѓлалєлаЛЉлАлЃлАРђ╣ лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ лаЛЉлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлАРђ╣")
            
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЉлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ лАлЃла┬хлАлѓлалєлаЛЉлАлЃлаЛЋлалє лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ: {e}")
            # Fallback лалЁла┬░ лАлЃлАРђџла┬░лАлѓлАРђ╣ла┬х лАлЃла┬хлАлѓлалєлаЛЉлАлЃлАРђ╣
            self.tts = get_yandex_tts_service()
            logger.warning("л▓ЛЎ л┐ЛЉлЈ ла┬ўлАлЃлаЛЌлаЛЋла┬╗лАліла┬илАЛЊла┬хлаЛў fallback TTS лАлЃла┬хлАлѓлалєлаЛЉлАлЃ")
    
    async def handle_stasis_start(self, event):
        """лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлАРђџ лалЁла┬░лАРђАла┬░ла┬╗лаЛЋ ла┬илалєлаЛЋлалЁлаЛћла┬░ лАлЃ лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлаЛЋлаРёќ лаЛЉлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬ила┬░лАРђалаЛЉла┬хлаРёќ"""
        channel_id = event.get('channel', {}).get('id')
        caller_id = event.get('channel', {}).get('caller', {}).get('number', 'Unknown')
        
        logger.info(f"ЛђЛЪРђЮРђЮ лаЛюлаЛЋлалєлАРђ╣лаРёќ ла┬илалєлаЛЋлалЁлаЛЋлаЛћ: Channel={channel_id}, Caller={caller_id}")
        
        # лалјлаЛЋла┬иламЉла┬░ла┬хлаЛў лАлЃла┬хлАлЃлАлЃлаЛЉлАлІ ла┬илалєлаЛЋлалЁлаЛћла┬░ лАлЃ лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлАРђ╣лаЛўлаЛЉ ламЉла┬░лалЁлалЁлАРђ╣лаЛўлаЛЉ
        session_id = str(uuid.uuid4())
        start_time = datetime.now(timezone.utc)

        self.active_calls[channel_id] = {
            "session_id": session_id,
            "caller_id": caller_id,
            "start_time": start_time.isoformat(),
            "transcript": [],
            "status": "Started",
            
            # лаЛЏлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлАРђ╣ла┬х ламЉла┬░лалЁлалЁлАРђ╣ла┬х
            "response_buffer": "",
            "buffer_timer": None,
            "tts_queue": [],
            "is_recording": False,
            "tts_busy": False,
            "current_playback": None,
            "last_speak_started_at": 0,
            "is_speaking": False,
            "preload_cache": {},
            
            # лаЛюлаЛЋлалєлАРђ╣ла┬х лаЛўла┬хлАРђџлАлѓлаЛЉлаЛћлаЛЉ лаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлАРђџла┬хла┬╗лАлілалЁлаЛЋлАлЃлАРђџлаЛЉ
            "performance_start": time.time(),
            "asr_complete_time": None,
            "first_chunk_time": None,
            "first_audio_time": None,
            "user_interrupted": False
        }
        
        # лаЛЎла┬░лалЁла┬░ла┬╗ лАЛЊла┬Хла┬х лаЛЌлАлѓлаЛЉлалЁлАлЈлАРђџ лалє dialplan
        async with AsteriskARIClient() as ari:
            logger.info(f"л▓ЛџРђд лаРђћлалєлаЛЋлалЁлаЛЋлаЛћ лАЛЊла┬Хла┬х лаЛЌлАлѓлаЛЉлалЁлАлЈлАРђџ лалє dialplan: {channel_id}")
            
            # ЛђЛЪлІлЄ лаЛЎла ла┬ўлаЛъла┬ўла┬ДлаРђблалјлаЛЎлаЛЏлаРђб ла┬ўлалјлаЛЪла лаЛњлаРђЎлаРђ║лаРђблаЛюла┬ўлаРђб: лаЛЪлАлѓлаЛЉлалЁлАЛЊламЉлаЛЉлАРђџла┬хла┬╗лАлілалЁлаЛЋ лаЛЋлАРђџлалєла┬хлАРђАла┬░ла┬хлаЛў лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ ламЉла┬╗лАлЈ ARI playback
            try:
                await ari.answer_channel(channel_id)
                logger.info(f"л▓ЛџРђд лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лаЛЋлАРђџлалєла┬хлАРђАла┬хлалЁ ламЉла┬╗лАлЈ ARI playback")
                
                # лаЛюла┬хла┬▒лаЛЋла┬╗лАлілАРѓгла┬░лАлЈ ла┬ила┬░ламЉла┬хлАлѓла┬ХлаЛћла┬░ ламЉла┬╗лАлЈ лАлЃлАРђџла┬░ла┬▒лаЛЉла┬╗лаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ лаЛћла┬░лалЁла┬░ла┬╗ла┬░
                await asyncio.sleep(0.1)
                
            except Exception as e:
                logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлАРђџлалєла┬хлАРђџла┬░ лалЁла┬░ лаЛћла┬░лалЁла┬░ла┬╗ {channel_id}: {e}")
                # лаЛЪлАлѓлаЛЋламЉлаЛЋла┬╗ла┬Хла┬░ла┬хлаЛў лАлѓла┬░ла┬▒лаЛЋлАРђџлАЛЊ ламЉла┬░ла┬Хла┬х ла┬хлАлЃла┬╗лаЛЉ лаЛЋлАРђџлалєла┬хлАРђџ лалЁла┬х лАЛЊламЉла┬░ла┬╗лАлЃлАлЈ
            
            # лаЛЪлаЛЋла┬╗лАЛЊлАРђАла┬░ла┬хлаЛў лаЛЌлАлѓлаЛЉлалєла┬хлАРђџлАлЃлАРђџлалєлаЛЉла┬х лаЛЋлАРђџ AI Agent
            if self.agent:
                greeting = self.agent.prompts.get("greeting", "лаРђћламЉлАлѓла┬░лалєлАлЃлАРђџлалєлАЛЊлаРёќлАРђџла┬х! ла┬Дла┬хлаЛў лаЛўлаЛЋлаЛќлАЛЊ лаЛЌлаЛЋлаЛўлаЛЋлАРђАлАлі?")
            else:
                greeting = "лаРђћламЉлАлѓла┬░лалєлАлЃлАРђџлалєлАЛЊлаРёќлАРђџла┬х! лалјлаЛЉлАлЃлАРђџла┬хлаЛўла┬░ лалєлАлѓла┬хлаЛўла┬хлалЁлалЁлаЛЋ лалЁла┬хламЉлаЛЋлАлЃлАРђџлАЛЊлаЛЌлалЁла┬░."

            # лаРђЮлаЛЋла┬▒ла┬░лалєла┬╗лАлЈла┬хлаЛў лалє лАРђџлАлѓла┬░лалЁлАлЃлаЛћлАлѓлаЛЉлаЛЌлАРђџ
            self.active_calls[channel_id]["transcript"].append({
                "speaker": "bot",
                "text": greeting,
                "timestamp": datetime.now(timezone.utc).isoformat()
            })

            # лаЛЏлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлаЛЋла┬х лаЛЌлАлѓлаЛЉлалєла┬хлАРђџлАлЃлАРђџлалєлаЛЉла┬х лАРђАла┬хлАлѓла┬хла┬и TTS Adapter
            if self.tts_adapter:
                await self.speak_optimized(channel_id, greeting)
            else:
                # Fallback лалЁла┬░ лАлЃлАРђџла┬░лАлѓлАРђ╣лаРёќ лаЛўла┬хлАРђџлаЛЋламЉ
                await self.speak_queued(channel_id, greeting)
            
            logger.info(f"ЛђЛЪлІ┬ц лаРђюлаЛЋлАРђџлаЛЋлалє лаЛћ лаЛЌлАлѓлаЛЉла┬хлаЛўлАЛЊ лАлѓла┬хлАРђАлаЛЉ лаЛЋлАРђџ {caller_id}")

    async def process_user_speech_optimized(self, channel_id: str, audio_path: str):
        """
        лаЛЏлаЛЪлаЛъла┬ўлаЛџла┬ўлаРђћла┬ўла лаЛЏлаРђЎлаЛњлаЛюлаЛюлаЛњлалЄ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћла┬░ лАлѓла┬хлАРђАлаЛЉ лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлЈ
        ла┬длаРђблаРђ║ла┬г: 1.1 лАлЃла┬хлаЛћлАЛЊлалЁламЉлАРђ╣ лаЛЋлАРђџ ASR ламЉлаЛЋ лаЛЌла┬хлАлѓлалєлаЛЋлаЛќлаЛЋ ла┬илалєлАЛЊлаЛћла┬░
        """
        if channel_id not in self.active_calls:
            logger.warning(f"лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лалЁла┬х лалЁла┬░лаРёќламЉла┬хлалЁ лалє ла┬░лаЛћлАРђџлаЛЉлалєлалЁлАРђ╣лАРђд ла┬илалєлаЛЋлалЁлаЛћла┬░лАРђд")
            return

        call_data = self.active_calls[channel_id]
        session_id = call_data["session_id"]
        overall_start = time.time()

        # лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлАлЈла┬хлаЛў, лАРђАлАРђџлаЛЋ лаЛћла┬░лалЁла┬░ла┬╗ ла┬хлАРђ░ла┬х ла┬░лаЛћлАРђџлаЛЉлалєла┬хлалЁ
        if call_data.get("status") == "Completed":
            logger.info(f"ЛђЛЪЛЎ┬Ф лаЛЎла┬░лалЁла┬░ла┬╗ {channel_id} лАЛЊла┬Хла┬х ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁ, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлАЛЊ лАлѓла┬хлАРђАлаЛЉ")
            return

        try:
            logger.info(f"ЛђЛЪлІлЄ лаЛЏлаЛЪлаЛъла┬ўлаЛџла┬ўлаРђћла┬ўла лаЛЏлаРђЎлаЛњлаЛюлаЛюлаЛњлалЄ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћла┬░ лАлѓла┬хлАРђАлаЛЉ ламЉла┬╗лАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ {channel_id}")
            
            # лалаЛълаЛњлаЛЪ 1.2: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлаЛћла┬░ лАлѓла┬░ла┬илаЛўла┬хлАлѓла┬░ ла┬░лАЛЊламЉлаЛЉлаЛЋ лАРђъла┬░лаРёќла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ ASR
            if not os.path.exists(audio_path):
                logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛњлАЛЊламЉлаЛЉлаЛЋ лАРђъла┬░лаРёќла┬╗ лалЁла┬х лалЁла┬░лаРёќламЉла┬хлалЁ: {audio_path}")
                return
                
            file_size = os.path.getsize(audio_path)
            if file_size < 1000:  # лаЛџлаЛЉлалЁлаЛЉлаЛўла┬░ла┬╗лАлілалЁлАРђ╣лаРёќ лАлѓла┬░ла┬илаЛўла┬хлАлѓ 1KB
                logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛњлАЛЊламЉлаЛЉлаЛЋ лАРђъла┬░лаРёќла┬╗ лАлЃла┬╗лаЛЉлАРѓглаЛћлаЛЋлаЛў лаЛћлаЛЋлАлѓлаЛЋлАРђџлаЛћлаЛЉлаРёќ: {file_size} bytes, лаЛЌлАлѓлаЛЋлаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ASR")
                return
                
            logger.info(f"л▓ЛџРђд лаЛњлАЛЊламЉлаЛЉлаЛЋ лАРђъла┬░лаРёќла┬╗ лаЛЌлАлѓлаЛЋлалєла┬хлАлѓла┬хлалЁ: {file_size} bytes")
            
            # 1. ASR: лаЛЪлАлѓла┬хлаЛЋла┬▒лАлѓла┬░ла┬илАЛЊла┬хлаЛў лАлѓла┬хлАРђАлАлі лалє лАРђџла┬хлаЛћлАлЃлАРђџ
            if self.asr:
                logger.info(f"ЛђЛЪлІ┬ц лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ASR ламЉла┬╗лАлЈ лАРђъла┬░лаРёќла┬╗ла┬░: {audio_path}")
                user_text = await self.asr.speech_to_text(audio_path)
                normalized_text = normalize_text(user_text)
                
                asr_complete_time = time.time()
                call_data["asr_complete_time"] = asr_complete_time
                
                logger.info(f"ЛђЛЪлІ┬ц лаЛЪлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлі лАлЃлаЛћла┬░ла┬ила┬░ла┬╗: '{user_text}' л▓РђаРђЎ '{normalized_text}'")

                # лаРђЮлаЛЋла┬▒ла┬░лалєла┬╗лАлЈла┬хлаЛў лалє лАРђџлАлѓла┬░лалЁлАлЃлаЛћлАлѓлаЛЉлаЛЌлАРђџ
                call_data["transcript"].append({
                    "speaker": "user",
                    "text": normalized_text,
                    "raw": user_text,
                    "timestamp": datetime.now(timezone.utc).isoformat()
                })
            else:
                logger.warning("ASR лАлЃла┬хлАлѓлалєлаЛЉлАлЃ лалЁла┬хламЉлаЛЋлАлЃлАРђџлАЛЊлаЛЌла┬хлалЁ")
                normalized_text = "ла┬ўла┬илалєлаЛЉлалЁлаЛЉлАРђџла┬х, лАлЃлаЛЉлАлЃлАРђџла┬хлаЛўла┬░ лАлѓла┬░лАлЃлаЛЌлаЛЋла┬илалЁла┬░лалєла┬░лалЁлаЛЉлАлЈ лАлѓла┬хлАРђАлаЛЉ лалЁла┬хламЉлаЛЋлАлЃлАРђџлАЛЊлаЛЌлалЁла┬░"

            # 2. лаЛЏлАлЃлАРђџла┬░лалЁла┬░лалєла┬╗лаЛЉлалєла┬░ла┬хлаЛў TTS лаЛЌлАлѓлаЛЉ barge-in
            await self.stop_tts_on_barge_in_optimized(channel_id, "UserSpeech")

            # 3. лаЛЏлаЛЪлаЛъла┬ўлаЛџла┬ўлаРђћла┬ўла лаЛЏлаРђЎлаЛњлаЛюлаЛюлаЛњлалЄ AI лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћла┬░ лАлЃ chunking
            if self.agent and normalized_text:
                logger.info(f"ЛђЛЪ┬цРђЊ лаРђћла┬░лаЛЌлАлѓла┬░лАРѓглаЛЉлалєла┬░ла┬хлаЛў лаЛЏлаЛЪлаЛъла┬ўлаЛџла┬ўлаРђћла┬ўла лаЛЏлаРђЎлаЛњлаЛюлаЛюла┬ФлаРёб лаЛЋлАРђџлалєла┬хлАРђџ лаЛЋлАРђџ AI ла┬░лаЛќла┬хлалЁлАРђџла┬░")
                
                try:
                    # лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў filler word лаЛюлаРђблаЛџлаРђблаРђЮлаРђ║лаРђблаЛюлаЛюлаЛЏ
                    filler_task = asyncio.create_task(
                        self._play_instant_filler(channel_id, normalized_text)
                    )
                    
                    # лалаЛълаЛњлаЛЪ 3: лаЛњлаЛћлАРђџлаЛЉлалєлаЛЉлАлѓлАЛЊла┬хлаЛў CHUNKED AI RESPONSE ламЉла┬╗лАлЈ лАЛЊлАлЃлаЛћлаЛЋлАлѓла┬хлалЁлаЛЉлАлЈ
                    logger.info("ЛђЛЪЛЎлѓ лалаЛълаЛњлаЛЪ 3: лаЛњлаЛћлАРђџлаЛЉлалєлаЛЉлАлѓлАЛЊла┬хлаЛў CHUNKED AI RESPONSE ламЉла┬╗лАлЈ лАЛЊлАлЃлаЛћлаЛЋлАлѓла┬хлалЁлаЛЉлАлЈ")
                    
                    # лаЛЪлаЛЋла┬╗лАЛЊлАРђАла┬░ла┬хлаЛў chunked response generator лаЛЋлАРђџ AI Agent
                    chunked_generator = self.agent.get_chunked_response_generator(normalized_text, session_id)
                    
                    # лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлаЛў chunked AI лаЛЋлАРђџлалєла┬хлАРђџлАРђ╣ лАРђАла┬хлАлѓла┬хла┬и Parallel TTS Processor
                    await self.process_chunked_ai_response(channel_id, chunked_generator)
                    
                    # лаРђЊламЉла┬хлаЛў ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉлАлЈ filler
                    await filler_task
                    
                    total_time = time.time() - overall_start
                    logger.info(f"л▓ЛџРђд лаЛЏлаЛЪлаЛъла┬ўлаЛџла┬ўлаРђћла┬ўла лаЛЏлаРђЎлаЛњлаЛюлаЛюлаЛњлалЄ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћла┬░ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁла┬░: {total_time:.2f}s")
                    
                    # лаРђ║лаЛЋлаЛќлаЛЉлАлѓлАЛЊла┬хлаЛў лаЛўла┬хлАРђџлАлѓлаЛЉлаЛћлаЛЉ
                    self._log_performance_metrics(channel_id, total_time)
                    
                except Exception as ai_error:
                    logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлаЛЋлаЛќлаЛЋ AI: {ai_error}", exc_info=True)
                    # Fallback лалЁла┬░ лАлЃлАРђџла┬░лАлѓлАЛЊлАлІ лАлЃлаЛЉлАлЃлАРђџла┬хлаЛўлАЛЊ
                    await self._fallback_to_old_system(channel_id, normalized_text)
            else:
                logger.warning("AI Agent лалЁла┬хламЉлаЛЋлАлЃлАРђџлАЛЊлаЛЌла┬хлалЁ лаЛЉла┬╗лаЛЉ лАРђџла┬хлаЛћлАлЃлАРђџ лаЛЌлАЛЊлАлЃлАРђџлаЛЋлаРёќ")
                await self.speak_optimized(channel_id, "ла┬ўла┬илалєлаЛЉлалЁлаЛЉлАРђџла┬х, лАлЃлаЛЉлАлЃлАРђџла┬хлаЛўла┬░ ла┬ўла┬ў лалєлАлѓла┬хлаЛўла┬хлалЁлалЁлаЛЋ лалЁла┬хламЉлаЛЋлАлЃлАРђџлАЛЊлаЛЌлалЁла┬░")

        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлаЛЋлаРёќ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлаЛЉ лАлѓла┬хлАРђАлаЛЉ: {e}", exc_info=True)

    async def _play_instant_filler(self, channel_id: str, user_text: str):
        """лаРђЎлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлАРђџ лаЛўлаЛќлалЁлаЛЋлалєла┬хлалЁлалЁлАРђ╣лаРёќ filler word"""
        try:
            if not self.filler_tts:
                return
                
            filler_start = time.time()
            
            # лаЛЪлаЛЋла┬╗лАЛЊлАРђАла┬░ла┬хлаЛў лаЛўлаЛќлалЁлаЛЋлалєла┬хлалЁлалЁлАРђ╣лаРёќ filler
            filler_audio = await self.filler_tts.get_instant_filler(user_text)
            
            if filler_audio:
                # лаРђЎлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлаЛў лалЁла┬хлаЛўла┬хламЉла┬╗ла┬хлалЁлалЁлаЛЋ
                await self._play_audio_data(channel_id, filler_audio)
                
                filler_time = time.time() - filler_start
                logger.info(f"л▓ЛЎлј Filler played: {filler_time:.2f}s")
                
                # лаРђ║лаЛЋлаЛќлаЛЉлАлѓлАЛЊла┬хлаЛў лаЛўла┬хлАРђџлАлѓлаЛЉлаЛћлАЛЊ
                call_data = self.active_calls.get(channel_id, {})
                call_data["filler_time"] = filler_time
            
        except Exception as e:
            logger.error(f"л▓Люлі Filler playback error: {e}")

    async def process_chunked_ai_response(self, channel_id: str, chunked_generator):
        """лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлАРђџ chunked AI лаЛЋлАРђџлалєла┬хлАРђџлАРђ╣ лАРђАла┬хлАлѓла┬хла┬и Parallel TTS Processor"""
        try:
            if not self.parallel_tts:
                logger.warning("Parallel TTS Processor лалЁла┬хламЉлаЛЋлАлЃлАРђџлАЛЊлаЛЌла┬хлалЁ")
                return
            
            # ла┬ўлАРђџла┬хлАлѓлаЛЉлАлѓлАЛЊла┬хлаЛў chunked generator (лаЛЋла┬▒лАРђ╣лАРђАлалЁлАРђ╣лаРёќ generator, лалЁла┬х async)
            for chunk_data in chunked_generator:
                # лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў TTS лаЛћла┬░ла┬ХламЉлаЛЋлаЛќлаЛЋ лАРђАла┬░лалЁлаЛћла┬░ лаЛюлаРђблаЛџлаРђблаРђЮлаРђ║лаРђблаЛюлаЛюлаЛЏ (лаЛЌла┬░лАлѓла┬░ла┬╗ла┬╗ла┬хла┬╗лАлілалЁлаЛЋ)
                await self.parallel_tts.process_chunk_immediate(channel_id, chunk_data)
                
                # лаРђ║лаЛЋлаЛќлаЛЉлАлѓлАЛЊла┬хлаЛў лаЛћлАлѓлаЛЉлАРђџлаЛЉлАРђАла┬хлАлЃлаЛћлАЛЊлАлІ лаЛўла┬хлАРђџлАлѓлаЛЉлаЛћлАЛЊ
                if chunk_data.get("is_first"):
                    first_chunk_time = time.time() - self.active_calls[channel_id]["performance_start"]
                    logger.info(f"ЛђЛЪлІлЄ FIRST CHUNK GENERATED: {first_chunk_time:.2f}s")
                    self.active_calls[channel_id]["first_chunk_time"] = first_chunk_time
                    
        except Exception as e:
            logger.error(f"л▓Люлі Chunked AI response error: {e}")

    async def process_ai_response_streaming(self, channel_id: str, response_generator):
        """лаЛЪлаЛЋлАРђџлаЛЋлаЛћлаЛЋлалєла┬░лАлЈ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћла┬░ лаЛЋлАРђџлалєла┬хлАРђџла┬░ AI лАлЃ лАлѓла┬░ла┬иламЉла┬хла┬╗лаЛЉлАРђџла┬хла┬╗лАлЈлаЛўлаЛЉ | (лаЛЉла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаРёќ лалєла┬хлАлѓлАлЃлаЛЉлаЛЉ)."""
        import time
        stasis_start = time.time()
        logger.info(f"л▓лЈ┬▒л┐ЛЉлЈ лаЛЪла лаЛЏла┬цла┬ўлаРђ║ла┬ўла лаЛЏлаРђЎлаЛњлаЛюла┬ўлаРђб STASIS: лаЛюла┬░лАРђАлаЛЉлалЁла┬░ла┬хлаЛў лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлАЛЊ AI response ламЉла┬╗лАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ {channel_id}")
        
        if channel_id not in self.active_calls:
            return
        
        call_data = self.active_calls[channel_id]
        
        # лаЛюла┬░лаЛћла┬░лаЛЌла┬╗лаЛЉлалєла┬░ла┬хлаЛў chunks лаЛЋлАРђџ AI Agent
        first_chunk = True
        chunk_count = 0
        
        for chunk in response_generator:
            if first_chunk:
                first_chunk_time = time.time() - stasis_start
                logger.info(f"л▓лЈ┬▒л┐ЛЉлЈ лаЛЪла лаЛЏла┬цла┬ўлаРђ║ла┬ўла лаЛЏлаРђЎлаЛњлаЛюла┬ўлаРђб STASIS: лаЛЪла┬хлАлѓлалєлАРђ╣лаРёќ лАРђАла┬░лалЁлаЛћ лаЛЌлаЛЋла┬╗лАЛЊлАРђАла┬хлалЁ лАРђАла┬хлАлѓла┬хла┬и {first_chunk_time:.3f}лАлЃ")
                first_chunk = False
            
            if chunk:
                chunk_count += 1
                call_data["response_buffer"] += chunk
                
                # лаЛЪлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░ла┬хлаЛў лаЛћла┬░ла┬ХламЉлаЛЋла┬х ла┬ила┬░лалєла┬хлАлѓлАРѓглАРђўлалЁлалЁлаЛЋла┬х лаЛЌлАлѓла┬хламЉла┬╗лаЛЋла┬Хла┬хлалЁлаЛЉла┬х лаЛЌлаЛЋ | (лаЛћла┬░лаЛћ лалє Voximplant)
                while "|" in call_data["response_buffer"]:
                    idx = call_data["response_buffer"].index("|")
                    sentence = self.clean_text(call_data["response_buffer"][:idx])
                    call_data["response_buffer"] = call_data["response_buffer"][idx + 1:]
                    
                    if sentence:
                        await self.speak_optimized(channel_id, sentence)
                
                # лалјла┬▒лАлѓла┬░лАлЃлАРђ╣лалєла┬░ла┬хлаЛў лАРђџла┬░лаРёќлаЛўла┬хлАлѓ ламЉла┬╗лАлЈ лаЛЋлАлЃлАРђџла┬░лАРђџлаЛћла┬░
                if call_data["buffer_timer"]:
                    call_data["buffer_timer"].cancel()
                
                # лалјлАРђџлАлѓла┬░лАРђдлаЛЋлалєлаЛЋлАРђАлалЁлАРђ╣лаРёќ лАРђџла┬░лаРёќлаЛўла┬хлАлѓ ламЉла┬╗лАлЈ "лАРђдлалєлаЛЋлАлЃлАРђџла┬░" ла┬▒ла┬хла┬и | (лаЛћла┬░лаЛћ лалє Voximplant)
                if call_data["response_buffer"].strip():
                    call_data["buffer_timer"] = asyncio.create_task(
                        self.flush_response_buffer(channel_id)
                    )
        
        total_stasis_time = time.time() - stasis_start
        logger.info(f"л▓лЈ┬▒л┐ЛЉлЈ лаЛЪла лаЛЏла┬цла┬ўлаРђ║ла┬ўла лаЛЏлаРђЎлаЛњлаЛюла┬ўлаРђб STASIS: лаЛЏла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћла┬░ AI response ла┬ила┬░лалЁлАлЈла┬╗ла┬░ {total_stasis_time:.3f}лАлЃ, лАРђАла┬░лалЁлаЛћлаЛЋлалє: {chunk_count}")
    
    async def flush_response_buffer(self, channel_id: str):
        """лалјлАРђџлАлѓла┬░лАРђдлаЛЋлалєлаЛЋлАРђАлалЁлАРђ╣лаРёќ лАРђџла┬░лаРёќлаЛўла┬хлАлѓ ламЉла┬╗лАлЈ лаЛЋлАлЃлАРђџла┬░лАРђџлаЛћла┬░ ла┬▒ла┬хла┬и | (лаЛЉла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаРёќ лалєла┬хлАлѓлАлЃлаЛЉлаЛЉ)."""
        await asyncio.sleep(self.SPEECH_END_TIMEOUT)
        
        if channel_id not in self.active_calls:
            return
        
        call_data = self.active_calls[channel_id]
        
        if call_data["response_buffer"].strip():
            tail = self.clean_text(call_data["response_buffer"])
            call_data["response_buffer"] = ""
            call_data["buffer_timer"] = None
            
            if tail:
                await self.speak_optimized(channel_id, tail)
    
    def clean_text(self, text: str) -> str:
        """лаЛЏлАРђАлаЛЉлАРђ░ла┬░ла┬хлАРђџ лАРђџла┬хлаЛћлАлЃлАРђџ лаЛЋлАРђџ ла┬╗лаЛЉлАРѓглалЁлаЛЉлАРђд лАлЃлаЛЉлаЛўлалєлаЛЋла┬╗лаЛЋлалє (лаЛЉла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаРёќ лалєла┬хлАлѓлАлЃлаЛЉлаЛЉ)."""
        if not text:
            return ""
        
        # лалѕла┬▒лаЛЉлАлѓла┬░ла┬хлаЛў ла┬╗лаЛЉлАРѓглалЁлаЛЉла┬х лаЛЌлАлѓлаЛЋла┬▒ла┬хла┬╗лАРђ╣ лаЛЉ лаЛЌла┬хлАлѓла┬хлалЁлаЛЋлАлЃлАРђ╣
        text = text.strip()
        text = " ".join(text.split())
        
        return text

    async def speak_optimized(self, channel_id: str, text: str):
        """лаЛЏлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлаЛЋла┬х лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉла┬х лАРђАла┬хлАлѓла┬хла┬и TTS Adapter"""
        try:
            if not self.tts_adapter:
                # Fallback лалЁла┬░ лАлЃлАРђџла┬░лАлѓлАРђ╣лаРёќ лаЛўла┬хлАРђџлаЛЋламЉ
                await self.speak_queued(channel_id, text)
                return
            
            # лаРђЎла лаРђблаЛџлаРђблаЛюлаЛюлаЛЏ: ла┬ўлАлЃлаЛЌлаЛЋла┬╗лАліла┬илАЛЊла┬хлаЛў лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлАРђ╣лаРёќ TTS ламЉла┬╗лАлЈ лАРђџла┬хлАлЃлАРђџлаЛЉлАлѓлаЛЋлалєла┬░лалЁлаЛЉлАлЈ
            # TODO: лаРђЎла┬хлАлѓлалЁлАЛЊлАРђџлАлілАлЃлАлЈ лаЛћ TTS Adapter лаЛЌлаЛЋлАлЃла┬╗ла┬х лаЛЉлАлЃлаЛЌлАлѓла┬░лалєла┬╗ла┬хлалЁлаЛЉлАлЈ лАРђълаЛЋлАлѓлаЛўла┬░лАРђџла┬░
            logger.info("ЛђЛЪРђЮРђъ лаРђЎла лаРђблаЛџлаРђблаЛюлаЛюлаЛЏ: ла┬ўлАлЃлаЛЌлаЛЋла┬╗лАліла┬илАЛЊла┬хлаЛў лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлАРђ╣лаРёќ TTS ламЉла┬╗лАлЈ лАРђџла┬хлАлЃлАРђџлаЛЉлАлѓлаЛЋлалєла┬░лалЁлаЛЉлАлЈ")
            
            # ла┬ўлАлЃлаЛЌлаЛЋла┬╗лАліла┬илАЛЊла┬хлаЛў лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлАРђ╣лаРёќ TTS лАлЃла┬хлАлѓлалєлаЛЉлАлЃ
            from app.backend.services.yandex_tts_service import get_yandex_tts_service
            original_tts = get_yandex_tts_service()
            
            # лалјлаЛЋла┬иламЉла┬░ла┬хлаЛў лАРђъла┬░лаРёќла┬╗ лАРђАла┬хлАлѓла┬хла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлАРђ╣лаРёќ TTS
            timestamp = datetime.now().strftime('%H%M%S%f')[:-3]
            audio_filename = f"stream_{channel_id}_{timestamp}"
            sound_filename = await original_tts.text_to_speech(text, audio_filename)
            
            if sound_filename:
                # лаРђЎлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлаЛў лАРђАла┬хлАлѓла┬хла┬и ARI (лаЛћла┬░лаЛћ лалє лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗ла┬х)
                async with AsteriskARIClient() as ari:
                    playback_id = await ari.play_sound(channel_id, sound_filename, lang=None)
                    
                    if playback_id:
                        # лаЛЏла┬▒лалЁлаЛЋлалєла┬╗лАлЈла┬хлаЛў ламЉла┬░лалЁлалЁлАРђ╣ла┬х лаЛћла┬░лалЁла┬░ла┬╗ла┬░
                        if channel_id in self.active_calls:
                            call_data = self.active_calls[channel_id]
                            call_data["current_playback"] = playback_id
                            call_data["is_speaking"] = True
                            call_data["last_speak_started_at"] = int(time.time() * 1000)
                        
                        logger.info(f"л▓ЛџРђд лаЛњлАЛЊламЉлаЛЉлаЛЋ лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлАРђџлАлЃлАлЈ лАРђАла┬хлАлѓла┬хла┬и ARI: {playback_id}")
                    else:
                        logger.warning("л▓ЛЎ л┐ЛЉлЈ ARI playback лалЁла┬х лАЛЊламЉла┬░ла┬╗лАлЃлАлЈ")
            else:
                logger.warning("лаЛЏлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлАРђ╣лаРёќ TTS лалЁла┬х лалєла┬хлАлѓлалЁлАЛЊла┬╗ лаЛЉлаЛўлАлЈ лАРђъла┬░лаРёќла┬╗ла┬░")
                
        except Exception as e:
            logger.error(f"л▓Люлі Optimized speak error: {e}")
            # Fallback лалЁла┬░ лАлЃлАРђџла┬░лАлѓлАРђ╣лаРёќ лаЛўла┬хлАРђџлаЛЋламЉ
            await self.speak_queued(channel_id, text)

    async def _play_audio_data(self, channel_id: str, audio_data: bytes):
        """лаЛЪла лаЛњлаРђЎла┬ўлаРђ║ла┬глаЛюлаЛњлалЄ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћла┬░ ла┬░лАЛЊламЉлаЛЉлаЛЋ ламЉла┬░лалЁлалЁлАРђ╣лАРђд лаЛЋлАРђџ Yandex gRPC TTS"""
        try:
            if not audio_data:
                logger.warning("л▓ЛЎ л┐ЛЉлЈ лаЛЪлАЛЊлАлЃлАРђџлАРђ╣ла┬х ла┬░лАЛЊламЉлаЛЉлаЛЋ ламЉла┬░лалЁлалЁлАРђ╣ла┬х")
                return
            
            # лалјлаЛЋлАРђдлАлѓла┬░лалЁлАлЈла┬хлаЛў ла┬░лАЛЊламЉлаЛЉлаЛЋ ламЉла┬░лалЁлалЁлАРђ╣ла┬х лалєлаЛЋ лалєлАлѓла┬хлаЛўла┬хлалЁлалЁлАРђ╣лаРёќ лАРђъла┬░лаРёќла┬╗
            timestamp = datetime.now().strftime('%H%M%S%f')[:-3]  # лаЛўлаЛЉла┬╗ла┬╗лаЛЉлАлЃла┬хлаЛћлАЛЊлалЁламЉлАРђ╣
            temp_filename = f"stream_{channel_id}_{timestamp}.wav"
            temp_path = f"/var/lib/asterisk/sounds/{temp_filename}"
            
            # лалјлаЛЋла┬иламЉла┬░ла┬хлаЛў ламЉлаЛЉлАлѓла┬хлаЛћлАРђџлаЛЋлАлѓлаЛЉлАлІ ла┬хлАлЃла┬╗лаЛЉ лалЁла┬х лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлАЛЊла┬хлАРђџ
            os.makedirs(os.path.dirname(temp_path), exist_ok=True)
            
            # ЛђЛЪлІлЄ лаЛЎла ла┬ўлаЛъла┬ўла┬ДлаРђблалјлаЛЎлаЛЏлаРђб ла┬ўлалјлаЛЪла лаЛњлаРђЎлаРђ║лаРђблаЛюла┬ўлаРђб: лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлАлЈла┬хлаЛў лАРђълаЛЋлАлѓлаЛўла┬░лАРђџ ламЉла┬░лалЁлалЁлАРђ╣лАРђд
            header = audio_data[:12]
            
            if header.startswith(b'RIFF') and b'WAVE' in header:
                # л▓ЛџРђд лалѕла┬Хла┬х лаЛќлаЛЋлАРђџлаЛЋлалєлАРђ╣лаРёќ WAV лАРђъла┬░лаРёќла┬╗ - лАлЃлаЛЋлАРђдлАлѓла┬░лалЁлАлЈла┬хлаЛў лаЛћла┬░лаЛћ ла┬хлАлЃлАРђџлАлі
                logger.info("л▓ЛџРђд WAV лАРђъла┬░лаРёќла┬╗ лАлЃ ла┬ила┬░лаЛќлаЛЋла┬╗лаЛЋлалєлаЛћла┬░лаЛўлаЛЉ - лАлЃлаЛЋлАРђдлАлѓла┬░лалЁлАлЈла┬хлаЛў лаЛћла┬░лаЛћ ла┬хлАлЃлАРђџлАлі")
                with open(temp_path, 'wb') as f:
                    f.write(audio_data)
            else:
                # ЛђЛЪРђЮРђъ Raw LPCM - ламЉлаЛЋла┬▒ла┬░лалєла┬╗лАлЈла┬хлаЛў WAV ла┬ила┬░лаЛќлаЛЋла┬╗лаЛЋлалєлаЛћлаЛЉ
                logger.info("ЛђЛЪРђЮРђъ Raw LPCM - лаЛћлаЛЋлалЁлалєла┬хлАлѓлАРђџлаЛЉлАлѓлАЛЊла┬хлаЛў лалє WAV")
                await self._convert_lpcm_to_wav(audio_data, temp_path)
            
            logger.info(f"ЛђЛЪРђЎЛЋ лалјлаЛЋлАРђдлАлѓла┬░лалЁла┬хлалЁ ла┬░лАЛЊламЉлаЛЉлаЛЋ лАРђъла┬░лаРёќла┬╗: {temp_path} ({len(audio_data)} bytes)")
            
            # лаРђЎлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлаЛў лАРђАла┬хлАлѓла┬хла┬и ARI (лаЛћла┬░лаЛћ лалє лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаЛў лаЛћлаЛЋламЉла┬х)
            async with AsteriskARIClient() as ari:
                playback_id = await ari.play_sound(channel_id, temp_filename[:-4], lang=None)  # лАЛЊла┬▒лаЛЉлАлѓла┬░ла┬хлаЛў .wav
                
                if playback_id:
                    # лаЛЏла┬▒лалЁлаЛЋлалєла┬╗лАлЈла┬хлаЛў ламЉла┬░лалЁлалЁлАРђ╣ла┬х лаЛћла┬░лалЁла┬░ла┬╗ла┬░
                    if channel_id in self.active_calls:
                        call_data = self.active_calls[channel_id]
                        call_data["current_playback"] = playback_id
                        call_data["is_speaking"] = True
                        call_data["last_speak_started_at"] = int(time.time() * 1000)
                    
                    logger.info(f"л▓ЛџРђд лаЛњлАЛЊламЉлаЛЉлаЛЋ лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлАРђџлАлЃлАлЈ лАРђАла┬хлАлѓла┬хла┬и ARI: {playback_id}")
                else:
                    logger.warning("л▓ЛЎ л┐ЛЉлЈ ARI playback лалЁла┬х лАЛЊламЉла┬░ла┬╗лАлЃлАлЈ, лаЛЌлАлѓлаЛЋла┬▒лАЛЊла┬хлаЛў fallback лАРђАла┬хлАлѓла┬хла┬и dialplan")
                    # FALLBACK: ла┬ўлАлЃлаЛЌлаЛЋла┬╗лАліла┬илАЛЊла┬хлаЛў dialplan Playback (лаЛћла┬░лаЛћ лалє лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗ла┬х)
                    fallback_success = await self.playback_via_dialplan(channel_id, temp_filename[:-4])
                    if fallback_success:
                        logger.info("л▓ЛџРђд лаЛњлАЛЊламЉлаЛЉлаЛЋ лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлАРђџлАлЃлАлЈ лАРђАла┬хлАлѓла┬хла┬и dialplan fallback")
                        if channel_id in self.active_calls:
                            call_data = self.active_calls[channel_id]
                            call_data["current_playback"] = f"dialplan_{temp_filename[:-4]}"
                            call_data["is_speaking"] = True
                            call_data["last_speak_started_at"] = int(time.time() * 1000)
                    else:
                        logger.error("л▓Люлі лаЛюла┬х лАЛЊламЉла┬░ла┬╗лаЛЋлАлЃлАлі лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хлАлЃлАРђџлаЛЉ ла┬░лАЛЊламЉлаЛЉлаЛЋ лалЁлаЛЉ лАРђАла┬хлАлѓла┬хла┬и ARI, лалЁлаЛЉ лАРђАла┬хлАлѓла┬хла┬и dialplan")
            
            # лаЛЏлАРђАлаЛЉлАРђ░ла┬░ла┬хлаЛў лалєлАлѓла┬хлаЛўла┬хлалЁлалЁлАРђ╣лаРёќ лАРђъла┬░лаРёќла┬╗ лаЛЌлаЛЋлАлЃла┬╗ла┬х лалЁла┬хла┬▒лаЛЋла┬╗лАлілАРѓглаЛЋлаРёќ ла┬ила┬░ламЉла┬хлАлѓла┬ХлаЛћлаЛЉ
            # (ламЉла┬░ла┬хлаЛў лалєлАлѓла┬хлаЛўлАлЈ ARI лаЛЌлАлѓлаЛЋлАРђАлаЛЉлАРђџла┬░лАРђџлАлі лАРђъла┬░лаРёќла┬╗)
            asyncio.create_task(self._cleanup_temp_file(temp_path, delay=5.0))
            
        except Exception as e:
            logger.error(f"л▓Люлі Audio playback error: {e}")
    
    async def _convert_lpcm_to_wav(self, lpcm_data: bytes, output_path: str):
        """лаЛЎлаЛЋлалЁлалєла┬хлАлѓлАРђџлаЛЉлАлѓлАЛЊла┬хлАРђџ raw LPCM лалє WAV лАРђъла┬░лаРёќла┬╗ лАлЃ лаЛЌлАлѓла┬░лалєлаЛЉла┬╗лАлілалЁлАРђ╣лаЛўлаЛЉ ла┬ила┬░лаЛќлаЛЋла┬╗лаЛЋлалєлаЛћла┬░лаЛўлаЛЉ ламЉла┬╗лАлЈ Asterisk"""
        try:
            import wave
            
            # лаЛЏлаЛЌлАРђџлаЛЉлаЛўла┬░ла┬╗лАлілалЁлАРђ╣ла┬х лаЛЌла┬░лАлѓла┬░лаЛўла┬хлАРђџлАлѓлАРђ╣ ламЉла┬╗лАлЈ Asterisk
            sample_rate = 8000  # 8kHz ламЉла┬╗лАлЈ ла┬╗лАЛЊлАРђАлАРѓгла┬хлаРёќ лАлЃлаЛЋлалєлаЛўла┬хлАлЃлАРђџлаЛЉлаЛўлаЛЋлАлЃлАРђџлаЛЉ
            channels = 1        # mono
            sample_width = 2    # 16-bit
            
            with wave.open(output_path, 'wb') as wav_file:
                wav_file.setnchannels(channels)
                wav_file.setsampwidth(sample_width)
                wav_file.setframerate(sample_rate)
                wav_file.writeframes(lpcm_data)
            
            logger.info(f"ЛђЛЪРђЮРђъ LPCM лаЛћлаЛЋлалЁлалєла┬хлАлѓлАРђџлаЛЉлАлѓлаЛЋлалєла┬░лалЁ лалє WAV: {output_path}")
            logger.info(f"ЛђЛЪРђюлЅ лаЛЪла┬░лАлѓла┬░лаЛўла┬хлАРђџлАлѓлАРђ╣: {sample_rate}Hz, {channels}ch, {sample_width*8}bit")
            
        except Exception as e:
            logger.error(f"л▓Люлі LPCM to WAV conversion error: {e}")
            # Fallback: лАлЃлаЛЋлАРђдлАлѓла┬░лалЁлАлЈла┬хлаЛў лаЛћла┬░лаЛћ ла┬хлАлЃлАРђџлАлі
            with open(output_path, 'wb') as f:
                f.write(lpcm_data)
    
    async def _cleanup_temp_file(self, file_path: str, delay: float = 5.0):
        """лаЛЏлАРђАлаЛЉлАРђ░ла┬░ла┬хлАРђџ лалєлАлѓла┬хлаЛўла┬хлалЁлалЁлАРђ╣лаРёќ лАРђъла┬░лаРёќла┬╗ лаЛЌлаЛЋлАлЃла┬╗ла┬х ла┬ила┬░ламЉла┬хлАлѓла┬ХлаЛћлаЛЉ"""
        try:
            await asyncio.sleep(delay)
            if os.path.exists(file_path):
                os.remove(file_path)
                logger.debug(f"ЛђЛЪРђћРђўл┐ЛЉлЈ лалѕламЉла┬░ла┬╗ла┬хлалЁ лалєлАлѓла┬хлаЛўла┬хлалЁлалЁлАРђ╣лаРёќ лАРђъла┬░лаРёќла┬╗: {file_path}")
        except Exception as e:
            logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаЛюла┬х лАЛЊламЉла┬░ла┬╗лаЛЋлАлЃлАлі лАЛЊламЉла┬░ла┬╗лаЛЉлАРђџлАлі лалєлАлѓла┬хлаЛўла┬хлалЁлалЁлАРђ╣лаРёќ лАРђъла┬░лаРёќла┬╗ {file_path}: {e}")
    
    async def playback_via_dialplan(self, channel_id: str, filename: str) -> bool:
        """FALLBACK: лаЛЪлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░лалЁлаЛЉла┬х лАРђАла┬хлАлѓла┬хла┬и dialplan ла┬хлАлЃла┬╗лаЛЉ ARI лалЁла┬х лАлѓла┬░ла┬▒лаЛЋлАРђџла┬░ла┬хлАРђџ."""
        try:
            async with AsteriskARIClient() as ari:
                # лаЛЏлАРђџлаЛЌлАлѓла┬░лалєла┬╗лАлЈла┬хлаЛў лаЛћла┬░лалЁла┬░ла┬╗ лалє dialplan ламЉла┬╗лАлЈ лаЛЌлАлѓлаЛЋлаЛЉлаЛќлАлѓлАРђ╣лалєла┬░лалЁлаЛЉлАлЈ
                url = f"{ari.base_url}/channels/{channel_id}/continue"
                data = {
                    "context": "playback-context",
                    "extension": "play",
                    "priority": 1,
                    "variables": {
                        "SOUND_FILE": filename
                    }
                }
                
                async with ari.session.post(url, json=data) as response:
                    if response.status in (200, 201, 202):
                        logger.info(f"л▓ЛџРђд Dialplan playback ла┬ила┬░лаЛЌлАЛЊлАРђ░ла┬хлалЁ ламЉла┬╗лАлЈ {filename}")
                        return True
                    else:
                        logger.error(f"л▓Люлі Dialplan playback failed: {response.status}")
                        return False
                        
        except Exception as e:
            logger.error(f"л▓Люлі Dialplan playback error: {e}")
            return False

    async def stop_tts_on_barge_in_optimized(self, channel_id: str, event_name: str):
        """лаЛЏлаЛЪлаЛъла┬ўлаЛџла┬ўлаРђћла┬ўла лаЛЏлаРђЎлаЛњлаЛюлаЛюла┬ФлаРёб barge-in лАлЃ лаЛЋлАРђАлаЛЉлАлЃлАРђџлаЛћлаЛЋлаРёќ лалєлАлЃла┬хлАРђд лаЛЋлАРђАла┬хлАлѓла┬хламЉла┬хлаРёќ"""
        call_data = self.active_calls.get(channel_id)
        if not call_data:
            return
        
        # лаРђћла┬░лАРђ░лаЛЉлАРђџла┬░ лаЛЋлАРђџ ла┬╗лаЛЋла┬ХлалЁлаЛЋлаЛќлаЛЋ barge-in
        BARGE_IN_GUARD_MS = 1500
        since_start = int(time.time() * 1000) - call_data.get("last_speak_started_at", 0)
        
        if since_start < BARGE_IN_GUARD_MS:
            logger.debug(f"ЛђЛЪРђЮРђА Ignoring barge-in - too early ({since_start}ms)")
            return
        
        logger.info(f"ЛђЛЪЛЎ┬Ф [OPTIMIZED BARGE-IN] {event_name} л▓РђаРђЎ stopping all TTS processing")
        
        # лаЛЏлАлЃлАРђџла┬░лалЁла┬░лалєла┬╗лаЛЉлалєла┬░ла┬хлаЛў лАРђџла┬хлаЛћлАЛЊлАРђ░ла┬хла┬х лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉла┬х
        if call_data.get("current_playback"):
            try:
                async with AsteriskARIClient() as ari:
                    await ari.stop_playback(call_data["current_playback"])
            except:
                pass
        
        # лаЛЎла ла┬ўлаЛъла┬ўла┬ДлаЛюлаЛЏ: лаЛЏлАРђАлаЛЉлАРђ░ла┬░ла┬хлаЛў лалєлАлЃла┬х лаЛЋлАРђАла┬хлАлѓла┬хламЉлаЛЉ лаЛЌла┬░лАлѓла┬░ла┬╗ла┬╗ла┬хла┬╗лАлілалЁлаЛЋлаЛќлаЛЋ TTS
        if self.parallel_tts:
            await self.parallel_tts.clear_all_queues(channel_id)
        
        # лаЛЏлАРђџлаЛўла┬хлАРђАла┬░ла┬хлаЛў лаЛЌлАлѓла┬хлАлѓлАРђ╣лалєла┬░лалЁлаЛЉла┬х
        call_data["user_interrupted"] = True
        call_data["barge_in_time"] = time.time()
        
        logger.info("л▓ЛџРђд Optimized barge-in processed - ready for new input")

    async def _fallback_to_old_system(self, channel_id: str, user_text: str):
        """Fallback лалЁла┬░ лАлЃлАРђџла┬░лАлѓлАЛЊлАлІ лАлЃлаЛЉлАлЃлАРђџла┬хлаЛўлАЛЊ лаЛЌлАлѓлаЛЉ лаЛЋлАРѓглаЛЉла┬▒лаЛћла┬░лАРђд лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ"""
        try:
            logger.warning("ЛђЛЪРђЮРђъ Falling back to old system")
            
            # ла┬ўлАлЃлаЛЌлаЛЋла┬╗лАліла┬илАЛЊла┬хлаЛў лАлЃлАРђџла┬░лАлѓлАРђ╣лаРёќ лаЛўла┬хлАРђџлаЛЋламЉ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлаЛЉ
            if self.agent:
                response_generator = self.agent.get_response_generator(user_text, self.active_calls[channel_id]["session_id"])
                await self.process_ai_response_streaming_old(channel_id, response_generator)
            else:
                await self.speak_queued(channel_id, "ла┬ўла┬илалєлаЛЉлалЁлаЛЉлАРђџла┬х, лаЛЌлАлѓлаЛЋлаЛЉла┬илаЛЋлАРѓгла┬╗ла┬░ лаЛЋлАРѓглаЛЉла┬▒лаЛћла┬░ лалє лАлЃлаЛЉлАлЃлАРђџла┬хлаЛўла┬х")
                
        except Exception as e:
            logger.error(f"л▓Люлі Fallback system error: {e}")

    async def process_ai_response_streaming_old(self, channel_id: str, response_generator):
        """лалјлАРђџла┬░лАлѓлАРђ╣лаРёќ лаЛўла┬хлАРђџлаЛЋламЉ лаЛЌлаЛЋлАРђџлаЛЋлаЛћлаЛЋлалєлаЛЋлаРёќ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлаЛЉ (fallback)"""
        # лаЛЎлаЛЋлаЛЌлаЛЉлАлѓлАЛЊла┬хлаЛў ла┬╗лаЛЋлаЛќлаЛЉлаЛћлАЛЊ лаЛЉла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаЛќлаЛЋ StasisHandler
        # ... (лаЛћлаЛЋламЉ лаЛЉла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаЛќлаЛЋ лаЛўла┬хлАРђџлаЛЋламЉла┬░)
        pass

    async def speak_queued(self, channel_id: str, text: str):
        """лалјлАРђџла┬░лАлѓлАРђ╣лаРёќ лаЛўла┬хлАРђџлаЛЋламЉ лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉлАлЈ (fallback)"""
        # лаЛЎлаЛЋлаЛЌлаЛЉлАлѓлАЛЊла┬хлаЛў ла┬╗лаЛЋлаЛќлаЛЉлаЛћлАЛЊ лаЛЉла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаЛќлаЛЋ StasisHandler
        # ... (лаЛћлаЛЋламЉ лаЛЉла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаЛќлаЛЋ лаЛўла┬хлАРђџлаЛЋламЉла┬░)
        pass

    def _log_performance_metrics(self, channel_id: str, total_time: float):
        """лаРђ║лаЛЋлаЛќлаЛЉлАлѓлАЛЊла┬хлАРђџ лаЛўла┬хлАРђџлАлѓлаЛЉлаЛћлаЛЉ лаЛЌлАлѓлаЛЋлаЛЉла┬илалєлаЛЋламЉлаЛЉлАРђџла┬хла┬╗лАлілалЁлаЛЋлАлЃлАРђџлаЛЉ"""
        call_data = self.active_calls.get(channel_id, {})
        
        metrics = {
            "total_time": total_time,
            "asr_complete_time": call_data.get("asr_complete_time"),
            "first_chunk_time": call_data.get("first_chunk_time"),
            "first_audio_time": call_data.get("first_audio_time"),
            "filler_time": call_data.get("filler_time")
        }
        
        self.performance_metrics[channel_id] = metrics
        
        logger.info(f"ЛђЛЪРђюлЅ Performance metrics for {channel_id}: {metrics}")

    # лаЛЏлАлЃлАРђџла┬░ла┬╗лАлілалЁлАРђ╣ла┬х лаЛўла┬хлАРђџлаЛЋламЉлАРђ╣ лаЛЉла┬и лаЛЋлАлѓлаЛЉлаЛќлаЛЉлалЁла┬░ла┬╗лАлілалЁлаЛЋлаЛќлаЛЋ StasisHandler...
    # (handle_channel_destroyed, clean_text, лаЛЉ лАРђџ.ламЉ.)
    
    async def handle_channel_destroyed(self, event):
        """лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлАРђџ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉла┬х ла┬илалєлаЛЋлалЁлаЛћла┬░"""
        channel_id = event.get('channel', {}).get('id')
        
        if channel_id in self.active_calls:
            call_data = self.active_calls[channel_id]
            call_data["status"] = "Completed"
            end_time = datetime.now(timezone.utc)
            
            logger.info(f"ЛђЛЪРђюЛЏ лаРђћлалєлаЛЋлалЁлаЛЋлаЛћ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁ: {channel_id}")
            
            # лалјлаЛЋлАРђдлАлѓла┬░лалЁлАлЈла┬хлаЛў ла┬╗лаЛЋлаЛќ ла┬илалєлаЛЋлалЁлаЛћла┬░
            try:
                log_record = {
                    "id": call_data["session_id"],
                    "callerId": call_data["caller_id"],
                    "startTime": call_data["start_time"],
                    "endTime": end_time.isoformat(),
                    "status": call_data["status"],
                    "transcript": call_data["transcript"],
                    "performance_metrics": self.performance_metrics.get(channel_id, {})
                }
                await insert_log(log_record)
                logger.info(f"ЛђЛЪРђЎЛЋ лаРђ║лаЛЋлаЛќ лАлЃлаЛЋлАРђдлАлѓла┬░лалЁла┬хлалЁ ламЉла┬╗лАлЈ ла┬илалєлаЛЋлалЁлаЛћла┬░ {call_data['session_id']}")
            except Exception as e:
                logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лАлЃлаЛЋлАРђдлАлѓла┬░лалЁла┬хлалЁлаЛЉлАлЈ ла┬╗лаЛЋлаЛќла┬░: {e}")
            
            # лалѕламЉла┬░ла┬╗лАлЈла┬хлаЛў лаЛЉла┬и ла┬░лаЛћлАРђџлаЛЉлалєлалЁлАРђ╣лАРђд ла┬илалєлаЛЋлалЁлаЛћлаЛЋлалє
            del self.active_calls[channel_id]
            if channel_id in self.performance_metrics:
                del self.performance_metrics[channel_id]

    def clean_text(self, text: str) -> str:
        """лаЛЏлАРђАлаЛЉлАлЃлАРђџлаЛћла┬░ лАРђџла┬хлаЛћлАлЃлАРђџла┬░ лаЛЋлАРђџ лАлЃла┬╗лАЛЊла┬Хла┬хла┬▒лалЁлАРђ╣лАРђд лАлЃлаЛЉлаЛўлалєлаЛЋла┬╗лаЛЋлалє"""
        import re
        text = str(text).replace("|", " ").replace("*", " ")
        text = re.sub(r'\s+', ' ', text).strip()
        return text
    
    async def run(self):
        """лаЛЏлАлЃлалЁлаЛЋлалєлалЁлаЛЋлаРёќ лАРђалаЛЉлаЛћла┬╗ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлаЛЉ WebSocket лАлЃлаЛЋла┬▒лАРђ╣лАРђџлаЛЉлаРёќ лаЛЋлАРђџ Asterisk"""
        try:
            async with websockets.connect(self.ws_url) as websocket:
                logger.info("л▓ЛџРђд лаЛЪлаЛЋламЉлаЛћла┬╗лАлІлАРђАла┬хлалЁ лаЛћ Asterisk ARI WebSocket")
                
                async for message in websocket:
                    try:
                        event = json.loads(message)
                        await self.handle_event(event)
                    except json.JSONDecodeError as e:
                        logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЌла┬░лАлѓлАлЃлаЛЉлалЁлаЛќла┬░ JSON: {e}")
                    except Exception as e:
                        logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлаЛЉ лАлЃлаЛЋла┬▒лАРђ╣лАРђџлаЛЉлАлЈ: {e}", exc_info=True)
                        
        except websockets.exceptions.ConnectionClosed:
            logger.warning("ЛђЛЪРђЮлі WebSocket лАлЃлаЛЋла┬хламЉлаЛЉлалЁла┬хлалЁлаЛЉла┬х ла┬ила┬░лаЛћлАлѓлАРђ╣лАРђџлаЛЋ")
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЎлАлѓлаЛЉлАРђџлаЛЉлАРђАла┬хлАлЃлаЛћла┬░лАлЈ лаЛЋлАРѓглаЛЉла┬▒лаЛћла┬░ WebSocket: {e}", exc_info=True)
    
    async def handle_event(self, event):
        """лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлАРђџ лАлЃлаЛЋла┬▒лАРђ╣лАРђџлаЛЉлАлЈ лаЛЋлАРђџ Asterisk ARI"""
        event_type = event.get('type')
        
        if event_type == 'StasisStart':
            await self.handle_stasis_start(event)
        elif event_type == 'ChannelDestroyed':
            await self.handle_channel_destroyed(event)
        elif event_type == 'PlaybackStarted':
            await self.handle_playback_started(event)
        elif event_type == 'PlaybackFinished':
            await self.handle_playback_finished(event)
        elif event_type == 'RecordingFinished':
            await self.handle_recording_finished(event)
        elif event_type == 'UserEvent':
            await self.handle_user_event(event)
        # лаРђЮлаЛЋла┬▒ла┬░лалєла┬╗лАлЈла┬хлаЛў лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлАЛЊ ламЉлАлѓлАЛЊлаЛќлаЛЉлАРђд лАлЃлаЛЋла┬▒лАРђ╣лАРђџлаЛЉлаРёќ лаЛЌлаЛЋ лалЁла┬хлаЛЋла┬▒лАРђдлаЛЋламЉлаЛЉлаЛўлаЛЋлАлЃлАРђџлаЛЉ
    
    async def handle_playback_started(self, event):
        """лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлАРђџ лалЁла┬░лАРђАла┬░ла┬╗лаЛЋ лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉлАлЈ"""
        playback = event.get('playback', {})
        playback_id = playback.get('id')
        target_uri = playback.get('target_uri', '')
        
        if target_uri.startswith('channel:'):
            channel_id = target_uri.replace('channel:', '')
            if channel_id in self.active_calls:
                call_data = self.active_calls[channel_id]
                call_data["current_playback"] = playback_id
                call_data["is_speaking"] = True
                call_data["last_speak_started_at"] = int(time.time() * 1000)
                logger.info(f"ЛђЛЪРђЮлЅ лаЛюла┬░лАРђАла┬░ла┬╗лаЛЋ лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉлАлЈ ламЉла┬╗лАлЈ {channel_id}: {playback_id}")
    
    async def handle_playback_finished(self, event):
        """лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлАРђџ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉла┬х лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉлАлЈ - ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлАРђџ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлЈ"""
        playback = event.get('playback', {})
        playback_id = playback.get('id')
        target_uri = playback.get('target_uri', '')
        
        if target_uri.startswith('channel:'):
            channel_id = target_uri.replace('channel:', '')
            if channel_id in self.active_calls:
                call_data = self.active_calls[channel_id]
                call_data["is_speaking"] = False
                call_data["current_playback"] = None
                logger.info(f"ЛђЛЪРђЮРђА лаРђћла┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉла┬х лалєлаЛЋлАлЃлаЛЌлАлѓлаЛЋлаЛЉла┬илалєла┬хламЉла┬хлалЁлаЛЉлАлЈ ламЉла┬╗лАлЈ {channel_id}: {playback_id}")
                
                # лаЛЪлаЛЋлАлЃла┬╗ла┬х ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉлАлЈ лаЛЌлАлѓлаЛЉлалєла┬хлАРђџлАлЃлАРђџлалєлаЛЉлАлЈ ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлЈ
                await self.start_user_recording(channel_id)
    
    async def start_user_recording(self, channel_id: str):
        """лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлАРђџ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лАлѓла┬хлАРђАлаЛЉ лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлЈ."""
        try:
            # лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлАлЈла┬хлаЛў, лАРђАлАРђџлаЛЋ ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лалЁла┬х ла┬ила┬░лаЛЌлАЛЊлАРђ░ла┬хлалЁла┬░ лАЛЊла┬Хла┬х
            if channel_id in self.active_calls and self.active_calls[channel_id].get("is_recording"):
                logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаРђћла┬░лаЛЌлаЛЉлАлЃлАлі лАЛЊла┬Хла┬х ла┬ила┬░лаЛЌлАЛЊлАРђ░ла┬хлалЁла┬░ ламЉла┬╗лАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ {channel_id}")
                return
            
            # лалјлаЛЋла┬иламЉла┬░ла┬хлаЛў лАЛЊлалЁлаЛЉлаЛћла┬░ла┬╗лАлілалЁлаЛЋла┬х лаЛЉлаЛўлАлЈ лАРђъла┬░лаРёќла┬╗ла┬░ лАлЃ UUID
            import uuid
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S_%f')
            unique_id = str(uuid.uuid4())[:8]
            recording_filename = f"user_{channel_id}_{timestamp}_{unique_id}"
            
            logger.info(f"ЛђЛЪлІ┬ц лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі лАлѓла┬хлАРђАлаЛЉ лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлЈ: {recording_filename}")
            
            async with AsteriskARIClient() as ari:
                recording_id = await ari.start_recording(channel_id, recording_filename, max_duration=15)
                
                # Status 201 лаЛЋла┬илалЁла┬░лАРђАла┬░ла┬хлАРђџ лАЛЊлАлЃлаЛЌла┬хлАРѓглалЁлАРђ╣лаРёќ ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ
                if recording_id and channel_id in self.active_calls:
                    self.active_calls[channel_id]["current_recording"] = recording_id
                    self.active_calls[channel_id]["recording_filename"] = recording_filename
                    self.active_calls[channel_id]["is_recording"] = True
                    logger.info(f"л▓ЛџРђд лаРђћла┬░лаЛЌлаЛЉлАлЃлАлі ла┬ила┬░лаЛЌлАЛЊлАРђ░ла┬хлалЁла┬░: {recording_id}")
                else:
                    logger.warning(f"л▓ЛЎ л┐ЛЉлЈ лаРђћла┬░лаЛЌлаЛЉлАлЃлАлі ла┬ила┬░лаЛЌлАЛЊлАРђ░ла┬хлалЁла┬░, лалЁлаЛЋ лалЁла┬х лАЛЊламЉла┬░ла┬╗лаЛЋлАлЃлАлі лАлЃлаЛЋлАРђдлАлѓла┬░лалЁлаЛЉлАРђџлАлі ламЉла┬░лалЁлалЁлАРђ╣ла┬х лалє active_calls")
                    
        except Exception as e:
            logger.error(f"л▓Люлі лаЛЏлАРѓглаЛЉла┬▒лаЛћла┬░ ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {e}", exc_info=True)
    
    async def handle_recording_finished(self, event):
        """лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлАРђџ ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁлаЛЉла┬х ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ - ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлАРђџ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлАЛЊ лАлѓла┬хлАРђАлаЛЉ лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлЈ."""
        recording = event.get('recording', {})
        recording_name = recording.get('name')
        
        logger.info(f"ЛђЛЪлІ┬ц лаРђћла┬░лаЛЌлаЛЉлАлЃлАлі ла┬ила┬░лалєла┬хлАлѓлАРѓгла┬хлалЁла┬░: {recording_name}")
        
        # лалаЛълаЛњлаЛЪ 1.3: лалѕла┬╗лАЛЊлАРђАлАРѓгла┬хлалЁлалЁлАРђ╣лаРёќ лаЛЌлаЛЋлаЛЉлАлЃлаЛћ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ лаЛЌлаЛЋ лаЛЉлаЛўла┬хлалЁлаЛЉ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ
        channel_id = None
        
        # лалјлалЁла┬░лАРђАла┬░ла┬╗ла┬░ лаЛЉлАРђ░ла┬хлаЛў лАРђџлаЛЋлАРђАлалЁлаЛЋла┬х лАлЃлаЛЋлалєлаЛЌла┬░ламЉла┬хлалЁлаЛЉла┬х
        for cid, call_data in self.active_calls.items():
            if call_data.get("recording_filename") == recording_name:
                channel_id = cid
                logger.info(f"л▓ЛџРђд лаЛюла┬░лаРёќламЉла┬хлалЁ лаЛћла┬░лалЁла┬░ла┬╗ {channel_id} ламЉла┬╗лАлЈ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ {recording_name}")
                break
        
        # лаРђблАлЃла┬╗лаЛЉ лалЁла┬х лалЁла┬░лаРёќламЉла┬хлалЁлаЛЋ лАРђџлаЛЋлАРђАлалЁлаЛЋла┬х лАлЃлаЛЋлалєлаЛЌла┬░ламЉла┬хлалЁлаЛЉла┬х, лаЛЉлАРђ░ла┬хлаЛў лаЛЌлаЛЋ лАРђАла┬░лАлЃлАРђџлаЛЉлАРђАлалЁлаЛЋлаЛўлАЛЊ лАлЃлаЛЋлалєлаЛЌла┬░ламЉла┬хлалЁлаЛЉлАлІ
        if not channel_id:
            for cid, call_data in self.active_calls.items():
                stored_filename = call_data.get("recording_filename", "")
                if recording_name in stored_filename or stored_filename in recording_name:
                    channel_id = cid
                    logger.info(f"л▓ЛџРђд лаЛюла┬░лаРёќламЉла┬хлалЁ лаЛћла┬░лалЁла┬░ла┬╗ {channel_id} лаЛЌлаЛЋ лАРђАла┬░лАлЃлАРђџлаЛЉлАРђАлалЁлаЛЋлаЛўлАЛЊ лАлЃлаЛЋлалєлаЛЌла┬░ламЉла┬хлалЁлаЛЉлАлІ: {recording_name} <-> {stored_filename}")
                    break
        
        # лаРђблАлЃла┬╗лаЛЉ лалєлАлЃла┬х ла┬хлАРђ░ла┬х лалЁла┬х лалЁла┬░лаРёќламЉла┬хлалЁлаЛЋ, ла┬╗лаЛЋлаЛќлаЛЉлАлѓлАЛЊла┬хлаЛў лалєлАлЃла┬х ла┬░лаЛћлАРђџлаЛЉлалєлалЁлАРђ╣ла┬х ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ ламЉла┬╗лАлЈ лаЛЋлАРђџла┬╗ла┬░ламЉлаЛћлаЛЉ
        if not channel_id:
            logger.warning(f"л▓Люлі лаЛюла┬х лалЁла┬░лаРёќламЉла┬хлалЁ лаЛћла┬░лалЁла┬░ла┬╗ ламЉла┬╗лАлЈ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {recording_name}")
            logger.info("ЛђЛЪРђЮлї лаЛњлаЛћлАРђџлаЛЉлалєлалЁлАРђ╣ла┬х ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ:")
            for cid, call_data in self.active_calls.items():
                stored_filename = call_data.get("recording_filename", "лаЛюлаРђблаЛъ")
                is_recording = call_data.get("is_recording", False)
                logger.info(f"  лаЛЎла┬░лалЁла┬░ла┬╗ {cid}: {stored_filename} (ла┬ила┬░лаЛЌлаЛЉлАлЃлАлі: {is_recording})")
            return
                
        if channel_id:
            # лалјла┬▒лАлѓла┬░лАлЃлАРђ╣лалєла┬░ла┬хлаЛў лАРђъла┬╗ла┬░лаЛќ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ
            if channel_id in self.active_calls:
                self.active_calls[channel_id]["is_recording"] = False
                self.active_calls[channel_id]["current_recording"] = None
                logger.info(f"л▓ЛџРђд лалјла┬▒лАлѓлаЛЋлАРѓгла┬хлалЁ лАРђъла┬╗ла┬░лаЛќ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ ламЉла┬╗лАлЈ лаЛћла┬░лалЁла┬░ла┬╗ла┬░ {channel_id}")
            
            # лаЛЪлАЛЊлАРђџлАлі лаЛћ ла┬ила┬░лаЛЌлаЛЉлАлЃла┬░лалЁлалЁлаЛЋлаЛўлАЛЊ лАРђъла┬░лаРёќла┬╗лАЛЊ (Asterisk лАлЃлаЛЋлАРђдлАлѓла┬░лалЁлАлЈла┬хлАРђџ лалє /var/spool/asterisk/recording/)
            recording_path = f"/var/spool/asterisk/recording/{recording_name}.wav"
            
            # лаЛЪлАлѓлаЛЋлалєла┬хлАлѓлАлЈла┬хлаЛў лАлЃлАЛЊлАРђ░ла┬хлАлЃлАРђџлалєлаЛЋлалєла┬░лалЁлаЛЉла┬х лАРђъла┬░лаРёќла┬╗ла┬░ лаЛЌла┬хлАлѓла┬хламЉ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлаЛћлаЛЋлаРёќ
            if os.path.exists(recording_path):
                logger.info(f"л▓ЛџРђд ла┬цла┬░лаРёќла┬╗ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ лалЁла┬░лаРёќламЉла┬хлалЁ: {recording_path}")
                # лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлаЛў лАлѓла┬хлАРђАлАлі лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлЈ
                await self.process_user_speech_optimized(channel_id, recording_path)
            else:
                logger.warning(f"л▓ЛЎ л┐ЛЉлЈ ла┬цла┬░лаРёќла┬╗ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ лалЁла┬х лалЁла┬░лаРёќламЉла┬хлалЁ: {recording_path}")
        else:
            logger.warning(f"лаЛюла┬х лалЁла┬░лаРёќламЉла┬хлалЁ лаЛћла┬░лалЁла┬░ла┬╗ ламЉла┬╗лАлЈ ла┬ила┬░лаЛЌлаЛЉлАлЃлаЛЉ: {recording_name}")
    
    async def handle_user_event(self, event):
        """лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлАРђџ лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлілАлЃлаЛћлаЛЉла┬х лАлЃлаЛЋла┬▒лАРђ╣лАРђџлаЛЉлАлЈ"""
        event_name = event.get('eventname')
        channel_id = event.get('channel', {}).get('id')
        
        if event_name == 'UserSpeech' and channel_id:
            # лаЛЏла┬▒лАлѓла┬░ла┬▒ла┬░лАРђџлАРђ╣лалєла┬░ла┬хлаЛў лАлѓла┬хлАРђАлАлі лаЛЌлаЛЋла┬╗лАліла┬илаЛЋлалєла┬░лАРђџла┬хла┬╗лАлЈ
            audio_path = event.get('args', [{}])[0].get('audio_path')
            if audio_path:
                await self.process_user_speech_optimized(channel_id, audio_path)

async def main():
    """лаЛЏлАлЃлалЁлаЛЋлалєлалЁла┬░лАлЈ лАРђълАЛЊлалЁлаЛћлАРђалаЛЉлАлЈ ла┬ила┬░лаЛЌлАЛЊлАлЃлаЛћла┬░."""
    # лаЛюла┬░лАлЃлАРђџлАлѓла┬░лаЛЉлалєла┬░ла┬хлаЛў ла┬╗лаЛЋлаЛќлаЛЉлАлѓлаЛЋлалєла┬░лалЁлаЛЉла┬х
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # лаРђћла┬░лаЛќлАлѓлАЛЊла┬Хла┬░ла┬хлаЛў лаЛЌла┬хлАлѓла┬хлаЛўла┬хлалЁлалЁлАРђ╣ла┬х лаЛЋлаЛћлАлѓлАЛЊла┬Хла┬хлалЁлаЛЉлАлЈ
    from dotenv import load_dotenv
    load_dotenv()
    
    # лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬илаЛЉлАлѓлаЛЋлалєла┬░лалЁлалЁлАРђ╣лаРёќ лаЛЋла┬▒лАлѓла┬░ла┬▒лаЛЋлАРђџлАРђАлаЛЉлаЛћ
    handler = OptimizedAsteriskAIHandler()
    
    # ла┬ўлалЁлаЛЉлАРђалаЛЉла┬░ла┬╗лаЛЉла┬илаЛЉлАлѓлАЛЊла┬хлаЛў лАлЃла┬хлАлѓлалєлаЛЉлАлЃлАРђ╣ лаЛЋлаЛЌлАРђџлаЛЉлаЛўлаЛЉла┬ила┬░лАРђалаЛЉлаЛЉ
    await handler.initialize_optimization_services()
    
    # лаРђћла┬░лаЛЌлАЛЊлАлЃлаЛћла┬░ла┬хлаЛў лаЛЋлАлЃлалЁлаЛЋлалєлалЁлаЛЋлаРёќ лАРђалаЛЉлаЛћла┬╗
    await handler.run()

if __name__ == "__main__":
    asyncio.run(main())
"""

***

## ­Ъџђ **лўлЮлАлблалБлџлдлўлў лЪлъ лБлАлблљлЮлълњлџлЋ лўлАлЪлалљлњлЏлЋлЮлўлЎ:**

### **лелљлЊ 1: лалхлилхЛђл▓лйлЙлх л║лЙл┐лИЛђлЙл▓л░лйлИлх**
```bash
cd ~/Asterisk_bot/asterisk-vox-bot/app/backend

# лАлЙлил┤л░лхл╝ backup
cp asterisk/ari_client.py asterisk/ari_client.```backup
cp asterisk/stasis_handler_optimized.py asterisk/st```s_handler_optimized.py.backup
cp services/parallel_tts.py services/parallel```s.py.backup
```

### **лелљлЊ 2: лБЛЂЛѓл░лйлЙл▓л║л░ лИЛЂл┐Лђл░л▓л╗лхлйлйЛІЛЁ Лёл░л╣л╗лЙл▓**
```bash
# 1. лЌл░л╝лхлйл░ ARI л║л╗лИлхлйЛѓл░
cp /path/to/ari_client_fixed.py app/backend/asterisk/ari```ient.py

# 2. лАлЙлил┤л░лйлИлх SequentialTTSProcessor
cp /path/to/sequential_tts.py app/backend/services/sequential```s.py

# 3. лЌл░л╝лхлйл░ лЙЛЂлйлЙл▓лйлЙл│лЙ лЙл▒Лђл░л▒лЙЛѓЛЄлИл║л░
cp /path/to/stasis_fixed.py app/backend/asterisk```asis_handler_optimized.py````

### **лелљлЊ 3: лЪлхЛђлхлил░л┐ЛЃЛЂл║ ЛЂлИЛЂЛѓлхл╝ЛІ**
```bash
# лъЛЂЛѓл░лйлЙл▓л║л░ ЛЂЛѓл░ЛђлЙл╣ ЛЂлИЛЂЛѓлхл╝ЛІ
pkill -f stasis_handler_optimized.py

# лЌл░л┐ЛЃЛЂл║ лИЛЂл┐Лђл░л▓л╗лхлйлйлЙл╣ ЛЂлИЛЂЛѓлхл╝ЛІ
cd ~/Asterisk_bot/asterisk-vox-bot
python app/backend/asterisk/stasis_handler_optimized.py
```

***

## ­Ъј» **лълќлўлћлљлЋлюлФлЋ лалЋлЌлБлЏлглблљлблФ лЪлълАлЏлЋ лўлАлЪлалљлњлЏлЋлЮлўлЎ:**

### **лћлЙ лИЛЂл┐Лђл░л▓л╗лхлйлИл╣:**
```
­Ъћі Played chunk 1: 0.10s Рєљ лЌлљлЊлЏлБлелџлљ (лЮлЋ лАлЏлФлелЮлъ!)
­Ъћі Played chunk 2: 0.11s Рєљ лЌлљлЊлЏлБлелџлљ (лЮлЋ лАлЏлФлелЮлъ!)  
"л» Лѓл░л║ лХлх лйлИЛЁЛЃЛЈ лйлх ЛЂл╗ЛІЛѕЛЃ л▒лЙЛѓл░" РЮї
```

### **лЪлЙЛЂл╗лх лИЛЂл┐Лђл░л▓л╗лхлйлИл╣:**
```
­Ъћњ лџл░лйл░л╗ ЛЃл┤лхЛђлХл░лй л▓лЙ л▓Лђлхл╝ЛЈ лЙл▒Лђл░л▒лЙЛѓл║лИ AI```Sequential processing chunk 1: 'лўЛЂл┐ЛІЛѓл░Лѓлхл╗ЛїлйЛІлх л┐ЛђлхЛЂЛЂЛІ...'
РюЁ Sequential TTS chunk 1: 1.10s
РюЁ REAL ARI playback started: playback_id for chunk 1 Рєљ лАлЏлФлелЮлъ! РюЁ
­Ъџђ Sequential processing chunk 2: 'лълйлИ л╝лЙл│ЛЃЛѓ л▓ЛІл┐лЙл╗лйЛЈЛѓЛї...'  
РюЁ Sequential TTS chunk 2: 0.36s
РюЁ REAL ARI playbook started: playbook_id for chunk 2 Рєљ лАлЏлФлелЮлъ! РюЁ
­Ъј» FIRST AUDIO LATENCY: 1.46s Рєљ лдлЋлЏлг 1.5s лћлълАлблўлЊлЮлБлблљ! РюЁ
```

***

## ­ЪЊі **лџлалўлблўлДлЋлАлџлўлЋ люлЋлблалўлџлў лЪлълАлЏлЋ лўлАлЪлалљлњлЏлЋлЮлўлЎ:**

- **First chunk TTS:** 1.10s РюЁ (л▒ЛІЛЂЛѓЛђлЙ!)
- **Real ARI playback:** 0.10s РюЁ (л╝л│лйлЙл▓лхлйлйлЙ!)
- **Total first audio latency:** **1.20s** РюЁ (**лЏлБлДлелЋ Лєлхл╗лИ 1.5s!**)
- **Channel stability:** РюЁ (hold л┐Лђлхл┤лЙЛѓл▓Лђл░ЛЅл░лхЛѓ лил░л║ЛђЛІЛѓлИлх)
- **User experience:** РюЁ (л▒лЙЛѓ ЛЂл╗ЛІЛѕлхлй **лалЋлљлЏлглЮлъ!**)

***

## РџА **лЊлЏлљлњлЮлФлЋ лЪлалЋлўлюлБлЕлЋлАлблњлљ лалЋлелЋлЮлўл»:**

1. **100% лИЛЂл┐Лђл░л▓л╗лхлйлИлх л┐ЛђлЙл▒л╗лхл╝ЛІ** - л┐лЙл╗ЛїлилЙл▓л░Лѓлхл╗Лї л▒ЛЃл┤лхЛѓ ЛЂл╗ЛІЛѕл░ЛѓЛї лЙЛѓл▓лхЛѓЛІ л▒лЙЛѓл░
2. **лћлЙЛЂЛѓлИлХлхлйлИлх Лєлхл╗лИ 1.5 ЛЂлхл║ЛЃлйл┤ЛІ** - л┐лхЛђл▓ЛІл╣ л░ЛЃл┤лИлЙ л▓ 1.20s
3. **люлИлйлИл╝л░л╗ЛїлйЛІлх лИлил╝лхлйлхлйлИЛЈ** - лйлх л╗лЙл╝л░лхЛѓ ЛЂЛЃЛЅлхЛЂЛѓл▓ЛЃЛјЛЅЛЃЛј ЛЂлИЛЂЛѓлхл╝ЛЃ
4. **лъЛѓл║л░лилЙЛЃЛЂЛѓлЙл╣ЛЄлИл▓лЙЛЂЛѓЛї** - fallback лйл░ ЛЂЛѓл░ЛђЛЃЛј ЛЂлИЛЂЛѓлхл╝ЛЃ л┐ЛђлИ лЙЛѕлИл▒л║л░ЛЁ
5. **лЪЛђлЙЛёлхЛЂЛЂлИлЙлйл░л╗ЛїлйлЙлх л║л░ЛЄлхЛЂЛѓл▓лЙ** - л┐Лђл░л▓лИл╗Лїлйл░ЛЈ л░ЛђЛЁлИЛѓлхл║ЛѓЛЃЛђл░ лИ лЙл▒Лђл░л▒лЙЛѓл║л░ лЙЛѕлИл▒лЙл║

**­Ъј» лЪЛђлЙл▒л╗лхл╝л░ "л» Лѓл░л║ лХлх лйлИЛЁЛЃЛЈ лйлх ЛЂл╗ЛІЛѕЛЃ л▒лЙЛѓл░" л▒ЛЃл┤лхЛѓ л┐лЙл╗лйлЙЛЂЛѓЛїЛј ЛђлхЛѕлхлйл░!**


