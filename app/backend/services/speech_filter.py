"""
Фильтр неинформативных фраз для голосового ассистента.
Определяет, содержит ли речь полезную информацию или это шум/согласие.

Вдохновлено решением из scenario_barge-in_2.js
"""

import logging
import re
from typing import List

logger = logging.getLogger(__name__)

class SpeechFilter:
    """
    Фильтр для определения информативности речи пользователя.
    Отсеивает короткие фразы, согласия и шум, фокусируется на осмысленных вопросах.
    """
    
    def __init__(self):
        """Инициализация фильтра."""
        # Список неинформативных фраз (согласия, звуки и т.д.)
        self.fillers: List[str] = [
            "да", "ага", "угу", "ну", "ок", "окей", "хорошо", "понятно", 
            "о", "угу-угу", "да-да", "ага-ага", "угу-угу", "окей", "ок",
            "угу", "угу угу", "ага ага", "да да", "понял", "поняла", "ясно"
        ]
        
        # Технические термины и маркеры (всегда считаются информативными)
        self.tech_terms: List[str] = [
            "кн", "кн", "килоньютон", "килоньютоны", "ка-эн", "кэ-эн", "к эн", "к эН", "кэн",
            "н", "ньютон", "ньютонов", "ньютоне",
            "н·м", "ньютон-метр", "ньютон метр", "н м", "н м",
            "н·мм", "ньютон миллиметр", "н мм", "н мм",
            "мпа", "мпа", "мэ-пэ-а", "эм-пэ-а", "мега паскаль", "мегапаскаль",
            "кпа", "кпа", "кэ-пэ-а", "килопаскаль", "кило паскаль", "паскаль", "па",
            "н/мм²", "ньютон на миллиметр квадратный", "н на мм2", "н/мм2",
            "гц", "герц", "частота в герцах",
            "мм", "миллиметр", "миллиметры", "миллиметров", "mm",
            "см", "сантиметр", "сантиметры", "сантиметров", "cm",
            "м", "метр", "метры", "метров",
            "мм/мин", "миллиметров в минуту", "мм в минуту",
            "мм/с", "миллиметров в секунду", "мм в секунду",
            "м/с", "метров в секунду",
            "об/мин", "rpm", "об в минуту",
            "кг", "килограмм", "килограмма", "килограммы", "kg",
            "грамм", "грамма", "граммы",
            "т", "тонна", "тонны",
            "%", "проценты", "процент",
            "л/мин", "литр в минуту", "литров в минуту", "l/min",
            "бар", "bar", "кгс/см²", "килограмм силы на сантиметр квадратный",
            "вт", "ватт", "w", "квт", "квт", "киловатт", "kw", "квт·ч", "квтч", "киловатт час",
            "в", "вольт", "v", "а", "ампер", "amp", "ом", "омы", "ohm", "ω",
            "дб", "децибел", "db",
            "мин/ч", "минут в час", "мин на час",
            "iso 7500-1", "astm e4", "iso 6892-1", "astm e8", "astm e9",
            "твердомер", "твердомеры", "твердомер роквелла", "твердомер бринелля", "твердомер виккерса", "микротвердомер",
            "разрывная машина", "разрывные машины", "испытательная машина", "испытательные машины", "универсальная разрывная машина",
            "испытательный пресс", "испытательные прессы", "пресс пи",
            "ргм", "ргм-1000", "ргм-1000-а",
            "динамическая машина", "усталостная машина",
            "испытание на растяжение", "испытание на сжатие", "испытание на изгиб", "метротэст",
            "ргм-г-а", "рэм", "рэм-i-0,1", "рэм-1", "рэм-50", "рэм-100", "рэм-200", "рэм-300", "рэм-500", "рэм-600",
            "рэм-i-2", "рэм-i-3", "рэм-i-5", "рэм-i-10",
            "уим-д", "уим-д-100", "уим-д-250", "уим-д-500", "уим-д-750", "пневмодинамическая машина",
            "пим-мр-100", "пим-мр-200", "пим-мр-300",
            "универсальные испытательные машины", "универсальная машина",
            "машина на усталость", "усталостные испытания",
            "машины на кручение", "машины на изгиб",
            "мк", "мкс", "мкс-1000", "мкс-2000", "мкс-3000", "мкс-500",
            "системы температурных испытаний", "сти",
            "экстензометр", "уид-пб", "m-view",
            "копра маятниковая", "копры", "км", "кв", "кмм", "икм-450-а",
            "стилоскоп", "слп", "сл-13у", "сл-15",
            "климатические камеры", "кх", "кио", "киу", "ктв", "ктз", "ктч",
            "ресурсное испытание", "испытание на износ",
            "машины шлифовально-полировальные", "мшп", "мп",
            "микроскоп металлографический", "мми", "ммр", "ммп",
            "лаборатория модульная", "лмм-25",
            "мебель лабораторная", "скз-1", "скз-2", "скз-3-а", "скз-4"
        ]
        
        # Вопросительные слова (указывают на вопросы)
        self.question_words: List[str] = [
            "что", "как", "где", "когда", "почему", "зачем", "кто", "чей", "какой",
            "какая", "какое", "какие", "сколько", "который", "которая", "которое",
            "можно", "возможно", "подскажите", "скажите", "расскажите"
        ]
        
        logger.info("SpeechFilter инициализирован")
    
    def is_informative(self, text: str) -> bool:
        """
        Проверяет, содержит ли речь полезную информацию.
        
        Args:
            text: Распознанный текст для анализа
            
        Returns:
            True, если текст информативный, иначе False
        """
        if not text:
            logger.debug("Текст пустой - не информативный")
            return False
        
        # Нормализация текста
        normalized_text = self._normalize_text(text)
        
        # Проверка длины
        if len(normalized_text) <= 2:
            logger.debug(f"Текст слишком короткий ({len(normalized_text)} символов) - не информативный")
            return False
        
        # Проверка на filler words
        if normalized_text.lower() in self.fillers:
            logger.debug(f"Текст является filler word: '{normalized_text}' - не информативный")
            return False
        
        # Проверка на наличие цифр (всегда информативно)
        if re.search(r'\d', normalized_text):
            logger.debug(f"Текст содержит цифры - информативный: '{normalized_text}'")
            return True
        
        # Проверка на технические термины (всегда информативно)
        text_lower = normalized_text.lower()
        for term in self.tech_terms:
            if term in text_lower:
                logger.debug(f"Текст содержит технический термин '{term}' - информативный: '{normalized_text}'")
                return True
        
        # Проверка на вопросительные слова
        for word in self.question_words:
            if word in text_lower:
                logger.debug(f"Текст содержит вопросительное слово '{word}' - информативный: '{normalized_text}'")
                return True
        
        # Проверка на минимальное количество слов
        words = normalized_text.split()
        if len(words) >= 3:
            logger.debug(f"Текст содержит {len(words)} слов - информативный: '{normalized_text}'")
            return True
        
        # Проверка на наличие глаголов (указывает на действие/запрос)
        common_verbs = ["хочу", "нужно", "требуется", "интересует", "ищу", "найти", 
                       "узнать", "получить", "купить", "заказать", "помочь", "сделать"]
        for verb in common_verbs:
            if verb in text_lower:
                logger.debug(f"Текст содержит глагол '{verb}' - информативный: '{normalized_text}'")
                return True
        
        logger.debug(f"Текст не прошел проверки на информативность: '{normalized_text}'")
        return False
    
    def _normalize_text(self, text: str) -> str:
        """
        Нормализует текст для анализа.
        
        Args:
            text: Исходный текст
            
        Returns:
            Нормализованный текст
        """
        if not text:
            return ""
        
        # Удаление лишних пробелов и знаков препинания
        normalized = text.strip()
        normalized = re.sub(r'[^\w\s]', ' ', normalized)  # Замена не-буквенно-цифровых символов на пробел
        normalized = re.sub(r'\s+', ' ', normalized)  # Удаление множественных пробелов
        
        return normalized.strip()
    
    def get_text_category(self, text: str) -> str:
        """
        Определяет категорию текста.
        
        Args:
            text: Текст для категоризации
            
        Returns:
            Категория текста: 'informative', 'filler', 'too_short', 'empty'
        """
        if not text:
            return 'empty'
        
        normalized = self._normalize_text(text)
        
        if len(normalized) <= 2:
            return 'too_short'
        
        if normalized.lower() in self.fillers:
            return 'filler'
        
        if self.is_informative(text):
            return 'informative'
        
        return 'filler'  # По умолчанию считаем неинформативным
    
    def get_detailed_analysis(self, text: str) -> dict:
        """
        Возвращает детальный анализ текста.
        
        Args:
            text: Текст для анализа
            
        Returns:
            Словарь с детальной информацией о тексте
        """
        normalized = self._normalize_text(text)
        text_lower = normalized.lower()
        
        analysis = {
            'original_text': text,
            'normalized_text': normalized,
            'length': len(normalized),
            'word_count': len(normalized.split()) if normalized else 0,
            'has_digits': bool(re.search(r'\d', normalized)),
            'has_tech_terms': [],
            'has_question_words': [],
            'category': self.get_text_category(text),
            'is_informative': self.is_informative(text)
        }
        
        # Поиск технических терминов
        for term in self.tech_terms:
            if term in text_lower:
                analysis['has_tech_terms'].append(term)
        
        # Поиск вопросительных слов
        for word in self.question_words:
            if word in text_lower:
                analysis['has_question_words'].append(word)
        
        return analysis
